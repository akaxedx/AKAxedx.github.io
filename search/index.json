[{"content":"JUC Java 中创建线程的方式 继承Thread类 1 2 3 4 5 6 7 8 9 10 11 public class TestThread extends Thread{ public static void main(String[] args) { TestThread thread = new TestThread(); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 由于 Java 是单继承，直接继承 Thread 会限制继承其他类，因此多用 Runnable 接口实现多线程 Thread 也是继承了 Runnable 接口的类，本质上还是等于继承了 Runnable 接口 实现Runnable接口 1 2 3 4 5 6 7 8 9 10 11 public class TestRunnable implements Runnable{ public static void main(String[] args) { Thread thread = new Thread(new TestRunnable()); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 匿名内部类实现多线程\n1 2 3 4 5 6 7 8 9 10 11 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } }); thread.start(); } } 使用 lambda 表达式简化\n1 2 3 4 5 6 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(() -\u0026gt; System.out.println(\u0026#34;111\u0026#34;)); thread.start(); } } 实现 Callable 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestCallable implements Callable\u0026lt;String\u0026gt; { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(new TestCallable()); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); System.out.println(result); } @Override public String call(){ return \u0026#34;111\u0026#34;; } } 与 Runnable 的区别在于可以拿到线程执行的结果，这里需要与 FutureTask 结合使用 而 FutureTask 是继承的 Runnable 接口和 Future 接口的接口 线程池创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestThreadPool implements Runnable{ public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new TestThreadPool()); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 总结 以上四种方式底层均为 Runnable 接口\n不建议使用 Executors 创建线程池的原因 FixedThreadPool 当我们使用 Executors 创建 FixedThreadPool 时，对应的构造方法为\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 这里 LinkedBlockingQueue 是一个无界的阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加进队列，会有 OOM 的风险 SingleThreadExecutor 当我们使用 Executors 创建 SingleThreadExecutor 时，对应的构造方法为\n1 2 3 4 5 6 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } 也是 LinkedBlockingQueue 总结 除了 OOM 的风险外，我们使用 Executors 来创建线程池也不能自定义线程的名字，不利于排查问题，所以应该用 ThreadPoolExecutor 直接定义线程池，可以灵活控制\n线程池有哪几种状态，每种状态分别表示什么 RUNNING 表示线程池正常运行，既能接收新任务，也会正常处理队列中的任务\nSHUTDOWN 当调用线程池 shutdown() 方法时，进入 SHUTDOWN 状态，表示线程池正处于关闭状态，不会接收新任务，但会继续把队列中的任务处理完\nSTOP 当调用线程池 shutdownnow() 方法时，线程池进入 STOP 状态，表示线程池正处于停止状态，此状态 不会接收新任务，也不会处理队列中的任务，正在运行的线程也会终断\nTIDYING 线程池中没有线程运行后，线程池状态自动变为 TIDYING，并且调用 terminated()，该方法是空方法，可以自行扩展\nTERMINATED terminated() 方法执行完后，线程池状态变为 TERMINATED\nSynchronized 和 ReentrantLock Synchronized ReentrantLock Java 中的一个关键值 JDK 提供的一个类 自动加锁与释放锁 手动加锁与释放 JVM 层面的锁 API 层面的锁 非公平锁 公平锁或非公平锁 锁的是对象，锁信息保存在对象头中 int 类型的 state 标识来标识锁的状态 底层有锁升级的过程 没有锁升级的过程 ReentrantLock分为公平和非公平锁，底层是怎么实现的 首先，不管是公平锁还是非公平锁，他们的底层实现都会用 AQS 来进行排队，他们的区别在于线程在使用 lock() 方法加锁时：\n公平锁：检查 AQS 队列中是否存在线程在排队，如果有，则当前线程也进行排队 非公平锁：不检查是否排队，直接竞争锁 总结 不管是否是公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁知识体现在的线程加锁阶段，而没有体现在线程被唤醒阶段\nReentrantLock 是可重入锁，不管是否公平\nSynchronized 锁是怎么升级的 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程 ID，该线程下次如果又来获取该锁就可以直接获取到了，也就是支持锁重入 轻量级锁：有偏向锁升级，当一个线程获取到锁后，此时这把锁是偏向锁，此时又有第二个线程来竞争锁，偏向锁会升级为轻量级锁，轻量级锁通过自旋实现，不会阻塞线程 自旋次数过多仍没有获取到锁，则会升级成重量级锁，重量级锁会导致线程阻塞 自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较耗费时间，自旋锁是线程通过 CAS 获取预期的一个标记，如果没获取到则循环获取，这个过程线程一直在运行中，没有使用太多操作系统资源，比较轻量 ThreadLocal的应用场景，底层实现是什么样的 ThreadLocal 底层 ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利用该机制将数据 缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据 ThreadLocal 底层是通过 ThreadLocalMap 实现的，每个 Thread 对象中都存在一个 ThreadLocalMap，Map 的 key 为 Threadlocal 对象，Map 的 value 为需要缓存的值 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestThreadLocal { private ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public void a() { local.set(\u0026#34;111\u0026#34;); b(); } public void b() { String s = local.get(); System.out.println(s); } } 在线程池中使用 ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使用完后，应该把设置的 key，value 也就是 Entry 对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap，ThreadLocalMap 也是通过强引用指向 Entry 对象，线程不被回收，Entry 对象也就不会回收，从而出现内存泄漏。解决方法是，在使用 ThreadLocal 对象后，手动调用 ThreadLocal d remove 方法，手动清除 Entry 对象 应用场景 一个经典的场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接）\n","date":"2024-08-25T05:53:40+08:00","image":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/698503_hu14773505816458707756.jpg","permalink":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/","title":"Java 基础"},{"content":"JAVA 基础 包含 Java SE、JUC等 Java 语言相关的特性\n具体地址\n","date":"2024-08-25T05:44:46+08:00","image":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B_hu13581451615509590227.PNG","permalink":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/","title":"备战秋招"},{"content":"\n","date":"2024-08-25T02:25:02+08:00","image":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/image-20240825022846591_hu11050290388165439678.png","permalink":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","title":"Spring 源码解析笔记"}]