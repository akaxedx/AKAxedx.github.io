[{"content":"JUC 对线程安全的理解 线程安全指的是，我们写的某段代码，在多个线程同时执行时，不会产生混乱，依然能够得到正常的结果，比如 i++，初始化为0，那么两个线程来同时执行这行代码，如果代码时线程安全的，那么最终结果应该就是一个线程的结果为1，一个线程结果为2，如果出现了两个线程结果都为1，则表示这段代码线程不安全\n对守护线程的理解 线程分为用户线程和守护线程，用户线程就是普通线程，守护线程时 JVM 的后台线程，比如垃圾回收线程就是一个守护线程，守护线程会在其他普通线程都停止运行后自动关闭，我们可以通过设置 thread.setDaemon(true) 来把一个线程设置为守护线程\n并发、并行、串行之间的区别 串行：一个任务执行完，才能执行下一个 并行：两个任务同时执行 并发：两个任务看上去是同时执行的，但实际上是任务被分成了很多分，然后一个一个执行 Java 避免死锁 造成死锁的原因 一个资源每次只能被一个线程使用 一个线程在阻塞等待某个资源时，不释放已占有资源 一个线程已经获得资源，在未使用完之前，不能强行剥夺 若干线程形成头尾相接的循环等待资源关系 这是形成死锁的必须达到的四个条件，只要不满足其中一个，就能避免死锁的形成，而前三个是作为锁的必要条件，所有打破第四个条件，不出现循环等待锁的关系\n开发注意事项 注意加锁顺序，保证每个线程按同样的顺序进行加锁 注意加锁时限，可以针对锁设置超时时间 注意死锁检查，确保在第一时间发现死锁并解决 Java 中创建线程的方式 继承Thread类 1 2 3 4 5 6 7 8 9 10 11 public class TestThread extends Thread{ public static void main(String[] args) { TestThread thread = new TestThread(); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 由于 Java 是单继承，直接继承 Thread 会限制继承其他类，因此多用 Runnable 接口实现多线程 Thread 也是继承了 Runnable 接口的类，本质上还是等于继承了 Runnable 接口 实现Runnable接口 1 2 3 4 5 6 7 8 9 10 11 public class TestRunnable implements Runnable{ public static void main(String[] args) { Thread thread = new Thread(new TestRunnable()); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 匿名内部类实现多线程\n1 2 3 4 5 6 7 8 9 10 11 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } }); thread.start(); } } 使用 lambda 表达式简化\n1 2 3 4 5 6 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(() -\u0026gt; System.out.println(\u0026#34;111\u0026#34;)); thread.start(); } } 实现 Callable 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestCallable implements Callable\u0026lt;String\u0026gt; { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(new TestCallable()); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); System.out.println(result); } @Override public String call(){ return \u0026#34;111\u0026#34;; } } 与 Runnable 的区别在于可以拿到线程执行的结果，这里需要与 FutureTask 结合使用 而 FutureTask 是继承的 Runnable 接口和 Future 接口的接口 线程池创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestThreadPool implements Runnable{ public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new TestThreadPool()); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 总结 以上四种方式底层均为 Runnable 接口\n线程池底层工作原理 线程池内部通过队列+线程实现的，我们利用线程池执行任务时\n如果此时线程池中的线程数量小于 corePoolSize，即线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务 如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue 未满，那么任务被放入缓冲队列 如果此时线程池中的线程数量大于等于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量小于 maximumPoolSize，建新的线程来处理被添加的任务 如果此时线程池中的线程数量大于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量等于 maximumPoolSize，那么通过 handler 所指定的策略来处理此任务 当线程池中的线程数量大于 corePoolSize，如果某线程空闲时间超过 keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数 线程池为什么是先添加队列而不是先创建最大线程 当线程池中的核心线程都在忙时，如果继续往线程池中添加任务，那么任务会先入队列，队列满了之后，才会开新线程。相当于一个公司有十个员工，本来十个员工可以正常处理各种需求，但是随着共公司的发展，需求在慢慢增加，但是一开始这些需求只会增加在待开发列表中，然后这十个员工从待开发列表中获取任务进行处理，但是某一天开发列表满了，十个员工彻底处理不过来了，才会招收新员工\n不建议使用 Executors 创建线程池的原因 FixedThreadPool 当我们使用 Executors 创建 FixedThreadPool 时，对应的构造方法为\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 这里 LinkedBlockingQueue 是一个无界的阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加进队列，会有 OOM 的风险 SingleThreadExecutor 当我们使用 Executors 创建 SingleThreadExecutor 时，对应的构造方法为\n1 2 3 4 5 6 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } 也是 LinkedBlockingQueue 总结 除了 OOM 的风险外，我们使用 Executors 来创建线程池也不能自定义线程的名字，不利于排查问题，所以应该用 ThreadPoolExecutor 直接定义线程池，可以灵活控制\n线程池有哪几种状态，每种状态分别表示什么 RUNNING 表示线程池正常运行，既能接收新任务，也会正常处理队列中的任务\nSHUTDOWN 当调用线程池 shutdown() 方法时，进入 SHUTDOWN 状态，表示线程池正处于关闭状态，不会接收新任务，但会继续把队列中的任务处理完\nSTOP 当调用线程池 shutdownnow() 方法时，线程池进入 STOP 状态，表示线程池正处于停止状态，此状态 不会接收新任务，也不会处理队列中的任务，正在运行的线程也会终断\nTIDYING 线程池中没有线程运行后，线程池状态自动变为 TIDYING，并且调用 terminated()，该方法是空方法，可以自行扩展\nTERMINATED terminated() 方法执行完后，线程池状态变为 TERMINATED\nSynchronized 和 ReentrantLock Synchronized ReentrantLock Java 中的一个关键值 JDK 提供的一个类 自动加锁与释放锁 手动加锁与释放 JVM 层面的锁 API 层面的锁 非公平锁 公平锁或非公平锁 锁的是对象，锁信息保存在对象头中 int 类型的 state 标识来标识锁的状态 底层有锁升级的过程 没有锁升级的过程 ReentrantLock 分为公平和非公平锁，底层是怎么实现的 首先，不管是公平锁还是非公平锁，他们的底层实现都会用 AQS 来进行排队，他们的区别在于线程在使用 lock() 方法加锁时：\n公平锁：检查 AQS 队列中是否存在线程在排队，如果有，则当前线程也进行排队 非公平锁：不检查是否排队，直接竞争锁 总结 不管是否是公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁知识体现在的线程加锁阶段，而没有体现在线程被唤醒阶段\nReentrantLock 是可重入锁，不管是否公平\nReentrantLock 中 tryLock 和 lock 方法的区别 tryLock 表示尝试加锁，可能加到可能加不到。该方法不会阻塞线程，加到返回 true，没有返回 false lock 表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值 CountDownLatch 和 Semaphore 的区别和底层原理 CountDownLatch CountDownLatch 表示计数器，可以给 CountDownLatch 设置一个数字，一个线程调用 CountDownLatch 的 await() 将会阻塞，其他线程可以调用 CountDownLatch 的 countDown() 方法来对 CountDownLatch 中的数字减一，当数字为 0 后，所有 await 的线程将会被唤醒\n原理：待用 await() 方法的线程会利用 AQS 排队，一旦数字被减为0，则会将 AQS 中排队的线程依此唤醒\nSemaphore Semaphore 表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过 acquire() 来获取许可，如果没有许可可用则线程阻塞，并通过 AQS 来排队，可以通过 release() 方法来释放许可，当某个线程释放了某个许可后，会从 AQS 中正在排队的第一个线程一次唤醒，直到没有空闲许可\n谈谈对 AQS 的理解，AQS 如何实现可重入锁 AQS 时一个 Java 线程同步的框架，是 JDK 中很多锁工具的核心实现框架 在 AQS 中，维护了一个信号量 state 和一个线程组成的双向链表队列，其中，这个线程队列，就是用来给线程排队用的，而state 就像是一个红绿灯，用来控制线程排队或者放行的，在不同场景下有不同的意义 在可重入锁这个场景下，state 就用来表示加锁次数，0表示无锁，每加一次锁，state 就加1，释放减1 Synchronized 锁是怎么升级的 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程 ID，该线程下次如果又来获取该锁就可以直接获取到了，也就是支持锁重入 轻量级锁：有偏向锁升级，当一个线程获取到锁后，此时这把锁是偏向锁，此时又有第二个线程来竞争锁，偏向锁会升级为轻量级锁，轻量级锁通过自旋实现，不会阻塞线程 自旋次数过多仍没有获取到锁，则会升级成重量级锁，重量级锁会导致线程阻塞 自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较耗费时间，自旋锁是线程通过 CAS 获取预期的一个标记，如果没获取到则循环获取，这个过程线程一直在运行中，没有使用太多操作系统资源，比较轻量 ThreadLocal的应用场景，底层实现是什么样的 ThreadLocal 底层 ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利用该机制将数据 缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据 ThreadLocal 底层是通过 ThreadLocalMap 实现的，每个 Thread 对象中都存在一个 ThreadLocalMap，Map 的 key 为 Threadlocal 对象，Map 的 value 为需要缓存的值 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestThreadLocal { private ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public void a() { local.set(\u0026#34;111\u0026#34;); b(); } public void b() { String s = local.get(); System.out.println(s); } } 在线程池中使用 ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使用完后，应该把设置的 key，value 也就是 Entry 对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap，ThreadLocalMap 也是通过强引用指向 Entry 对象，线程不被回收，Entry 对象也就不会回收，从而出现内存泄漏。解决方法是，在使用 ThreadLocal 对象后，手动调用 ThreadLocal d remove 方法，手动清除 Entry 对象 应用场景 一个经典的场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接\n","date":"2024-09-05T08:17:38+08:00","image":"https://akaxedx.github.io/p/%E6%B7%98%E6%B1%B0%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/zoye_hu11211305020165925006.jpeg","permalink":"https://akaxedx.github.io/p/%E6%B7%98%E6%B1%B0%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/","title":"淘汰文章合集"},{"content":"设计模式 设计模式相关内容介绍 设计模式概述 软件设计模式的产生背景 \u0026ldquo;设计模式\u0026quot;最初并不是出现在软件设计中，而是被用于建筑领域的设计中。1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大(christopher lexander)在他的著作《建筑模式语言:城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马(ErichGamma)理査德·海尔姆(Richard Helm)、拉尔夫·约翰森(Ralph Johnson)、约翰·威利斯迪斯(John vlissides)等4 位作者合作出版了《设计模式:可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”(Gang of Four，GoE)著称。\n软件设计模式的概念 软件设计模式(software Design pattern)，又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路,是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。\n学习设计模式的必要性 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点。\n可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 设计模式的分类 创建型模式 用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离\u0026rdquo;。GoE(四人组)书中提供了单例、原型、工厂方法、抽象工 厂、建造者等 5 种创建型模式。 结构型模式 用于描述如何将类或对象按某种布局组成更大的结构，çE(四人组)书中提供了代理、适配器、桥接、装饰、外观、享元、组合等7 种结构型模式。 行为型模式 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoE(四人组)书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式 UML 图 统一建模语言(Unified Modeling Language，UML)是用来设计软件的可视化建模语言。它的特点是简单、统图形化、能表达软件设计中的动态与静态信息。 UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图部署图等 9 种图。\n类图概述 类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\n类图的作用 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解; 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 类图表示法 类的表示方式 在UML类图中，类使用包含类名、属性(field)和方法(method)且带有分割线的矩形来表示，比如下图表示一个Employee类，它包 含name，age和address这3个属性，以及work()方法。\n属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，双…类图中表示可见性的符号有三种:\n+：表示public -：表示private #：表示protected 属性的完整表示方式是：可见性\t名称 :类型 [= 缺省值] 方法的完整表示方式是：可见性\t名称(参数列表)[:返回类型]\n注意: 1，中括号中的内容表示是可选的 2，也有将类型放在变量名前面，返回值类型放在方法名前面\n类和类之间关系的表示方式 关联关系 关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。关联又可以分为单向关联，双向关联，自关联。\n单向关联 在WI.类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址， 这通过让Customer类持有一个类型为Address的成员变量类实现。\n双向关联 从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。 在UML类图中，双向关联用一个不带箭头的直线表示。上图中在customer类中维护一个List\u0026lt;Product\u0026gt;，表示一个顾客可以购买多个 商品;在Product类中维护一个customer类型的成员变量表示这个产品被哪个顾客所购买。\n自关联 自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”\n聚合关系 聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。在 UML 类图中，聚合关系可以用带空心萎形的实线来表示，萎形指向整体。下图所示是大学和教师的关系图:\n组合关系 组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，也就不存在了，在 UML 类图中，组合关系用带实心萎形的实线来表示，萎形指向整体。下图所示是头和嘴的关系图:\n依赖关系 依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类(被依赖类)中的某些方法来完成一些职责。\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车:\n继承关系 继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。 在 UML 类图中，泛化系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示:\n实现关系 实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图下所示：\n软件设计原则 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本\n开闭原则 对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\n想要达到这样的效果，我们需要使用接口和抽象类。\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n下面以 搜狗输入法，的皮肤为例介绍开闭原则的应用。 【例】 搜狗输入法 的皮肤设计。 分析: 搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类(Abstractskin)，而每个具体的皮肤(Defaultspecificskin 和 eimaspecificskin)是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public abstract class AbstractSkin { public abstract void display(); } ----------------------------------------------------------- public class DefaultSpecificSkin extends AbstractSkin{ @Override public void display() { System.out.println(\u0026#34;DefaultSpecificSkin display\u0026#34;); } } ----------------------------------------------------------- public class MySkin extends AbstractSkin{ @Override public void display() { System.out.println(\u0026#34;显示蓝色皮肤\u0026#34;); } } ----------------------------------------------------------- public class SouGouInput { private AbstractSkin skin; public void setSkin(AbstractSkin skin){ this.skin = skin; } public void display(){ skin.display(); } } ----------------------------------------------------------- public class Main { public static void main(String[] args) { SouGouInput input = new SouGouInput(); // DefaultSpecificSkin skin = new DefaultSpecificSkin(); MySkin skin = new MySkin(); input.setSkin(skin); input.display(); } } 里氏代换原则 里氏代换原则是面向对象设计的基本原则之一。\n里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时程序运行出错的概率会非常大。\n下面看一个里氏替换原则中经典的一个例子\n【例】正方形不是长方形。\n在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class Rectangle { private double length; private double width; public double getLength() { return length; } public double getWidth() { return width; } public void setLength(double length) { this.length = length; } public void setWidth(double width) { this.width = width; } } ----------------------------------------------------------- public class Square extends Rectangle{ @Override public void setLength(double length) { super.setLength(length); super.setWidth(length); } @Override public void setWidth(double width) { super.setWidth(width); super.setLength(width); } } ----------------------------------------------------------- public class RectangleDemo { public static void main(String[] args) { Rectangle r = new Rectangle(); r.setLength(20); r.setWidth(10); resize(r); printLengthAndWidth(r); System.out.println(\u0026#34;===========================\u0026#34;); Square s = new Square(); s.setLength(20); resize(s); printLengthAndWidth(s); } public static void resize(Rectangle rectangle) { while (rectangle.getWidth() \u0026lt;= rectangle.getLength()) { rectangle.setWidth(rectangle.getWidth() + 1); } } public static void printLengthAndWidth(Rectangle rectangle) { System.out.println(\u0026#34;length: \u0026#34; + rectangle.getLength() + \u0026#34;, width: \u0026#34; + rectangle.getWidth()); } } 我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入 resize 方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期;假如我们再把一个正方形作为参数传入 resize 方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。我们得出结论：在resize方法中，Rectangle类型的参数是不能被square类型的参数所代替，如果进行了替换就得不到预期结果。因此，square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。\n如何改进呢?此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和square类实现Quadrilateral接口\n依赖倒转原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象;抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n下面看一个例子来理解依赖倒转原则\n【例】组装电脑\n现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Inte1，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。\n","date":"2024-09-03T15:28:04+08:00","image":"https://akaxedx.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zoye_hu5843364884554689153.jpg","permalink":"https://akaxedx.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式"},{"content":"数据库相关 Mybatis 的优缺点 优点 基于 SQL 语言编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，基础 SQL 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用 与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接 很好的与各种数据库兼容（因为 Mybatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 Mybatis 都支持） 能够与 Spring 很好的集成 提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护 缺点 SQL 语句的编写工作量大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求 SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库 #{} 和 ${} 的区别 #{} 是预编译处理、是占位符，${} 是字符串替换、是拼接符\nMybatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ? ，调用 PreparedStatement 来赋值\nMybatis 在处理 ${} 时，会将 SQL 中的 ${} 替换成变量的值，调用 Statement 来赋值\n使用 #{} 可以有效地防止 SQL 注入，提高系统安全性\n索引的基本原理 索引用来快速地寻找那些具有特定值的记录，如果没有索引，一般来说执行查询时遍历整张表\n索引的原理：就是把无序的数据编程有序的查询\n把创建了索引的列的内容进行排序 对排序结果生成倒排表 在倒排表内容上拼上数据地址链 在查询时先拿到倒排表内容，再取出数据的地址链，从而拿到具体数据 索引设计的原则 查询更快，占用空间更小\n适合索引的列时出现再 where 子句中的列，或者连接子句中指定的列 基数较小的类，索引效果较差，没必要在此列建立索引 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配 不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。再修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个事件就会越长。所以只要保持需要的索引有利于查询即可 定义有外键的数据列一定要建立索引 更新频繁字段不适合创建索引 若是不能有效区分数据的列不适合做索引列（如性别） 尽量的扩展索引，不要新建索引，比如表中已经有 a 的索引，现在要加 (a,b) 的 索引，那么只需要修改原来的索引即可 对于哪些查询中很少涉及的列，重复值比较多的列不要建立索引 对于定义为 text、image 和 bit 的数据类型的列不要建立索引 事务的基本特性和隔离级别 事务基本特性 ACID 原子性 指的是一个事务中的操作要么全部成功，要么全部失败\n一致性 指的是数据库总是从一个一致性的状态转换到另一个一致性的状态。比如 A 转账给 B 100 元，假设 A 只有 90 元，支付之前我们数据库里的数据都是符合约束的，但是如果事务执行成功，数据库数据就破坏约束了，因此事务不能成功\n隔离性 指的是一个事务的修改再最终提交前，对其他事务是不可见的\n持久性 指的是一旦事务提交，所做的修改就会永久保存到数据库中\n隔离性的四个隔离级别 read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读，用户本来应该读取到 id = 1的用户 age 应该是 10，结果读到了其他事务还没有提交的事务，结果读取结果 age = 20，这就是脏读 read commit 读已提交，两次读取结果不一致，也叫不可重复读，不可重复读解决了脏读的问题，他只会读取已经提交的事务。用户开启事务读取 id = 1的用户，查询到 age = 10，再次读取发现结果未 20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读 repeatable read 可重复读，mysql 默认级别，每次读取结果都一样，但是可能产生幻读 serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题 什么是 MVCC 多版本并发控制，指的是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务在执行普通 SELECT 操作时访问记录的版本链的过程。可以使用不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大的不同是：生成 ReadView 的时机不同，READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView\nMyISAM 和 InnoDB 的区别 MyISAM 不支持事务，但是每次查询都是原子的 支持表级锁，每次操作对整个表加锁 存储表的总行数 一个 MyISAM 表有三个文件：索引文件，表结构文件，数据文件 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性 InnoDB 支持 ACID 的事务 支持事务的四种隔离级别 支持行级锁以及外键约束，因此可以支持写并发 不存储行总数 一个 InnoDB 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件中），也可能未多个（设置为独立表空间，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+ 树结构，文件的大调整 Explain 语句结果中各个字段分别表示什么 列名 描述 id 查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样 select_type SELECT 关键字对应的那个查询类型 table 表名 partitions 匹配的分区信息 type 针对单表的查询方式（全表扫描、索引） possible_keys 可能用到的索引 key 实际上使用的索引 ken_len 实际上使用的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filterte 某个表经过 搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息，比如排列 索引覆盖是什么 索引覆盖就是一个 SQL 再执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包含了，那么就表示此 SQL 走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回\n最左前缀原则 当一个 SQL 想要利用索引时，就一定要提供该索引锁对应的字段中最左边的字段，也iu是排在最前面的字段，比如针对 a,b,c 三个字段建立了一个联合索引，那么在写以恶搞 SQL 时就一定要提供 a 字段的条件，这样才能用到联合索引，这是由于建立 a,b,c 三个字段的联合索引时，底层的 B+ 树时按照 a,b,c 三个字段从左往右去比较大小进行排序的，所以如果想要利用 B+ 树进行快速查找也得符合这个规则\nInnoDB 是如何实现事务的 InnoDB 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 update 语句为例\nInnoDB 在收到一个 update 后，会先根据条件找到数据所在的也，并将该页缓存在 Buffer Pool 中 执行 update 语句，修改 Buffer Pool 重点数据，也就是内存中的数据 针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中 针对 update 语句生成 undolog 日志，用于事务回滚 如果事务提交，那么把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中 如果事务回滚，那么利用 undolog 日志进行回滚 B 树和 B+ 树的区别，为什么 Mysql 使用 B+ 树 B 树的特点\n节点排序 一个节点可以存放多个元素 B+ 树的特点\n拥有 B 树的特点 叶子节点之间有指针 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好序 Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 树通过对数据进行 排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使 B+ 树的高度不会太高，在 Mysql 中一个 InnoDB 页就是一个 B+ 树节点，一个 InnoDB 页默认 16kb，所以一般情况下一棵两层的 B+ 树可以存 2000万行左右的数据，然后利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子几点之间有指针，可以很好的支持全表扫描，范围查找等 SQL\nMysql 锁有哪些，如何理解 按粒度分类\n行锁：锁某行数据，锁粒度最小，并发度高 表锁：锁整张表，锁粒度最大，并发度低 间隙锁：锁的是一个区间 按读写分\n共享锁：读锁，一个事务给某行数据加了读锁，其他事务可以读，但不能写 排他锁：写锁，一个事务给某行数据加了写锁，其他事务不能读不能写 按实现方式\n乐观锁：不会真正去锁某行记录，通过一个版本号来实现 乐观锁：上面的行锁、表锁都是悲观锁 在事务的隔离级别实现中，就需要利用锁来解决幻读\nRedis 的过期键的删除策略 Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。Redis 的过期策略就是指当 Redis 中缓存的 key 过期了，Redis 如何处理\n惰性过期：只有当访问一个 key 时，才会判断该 key 是否已经过期，过期则清除。该策略可以最大化节省 CPU 资源，对内存不友好，极端情况下可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存 定时过期（Redis 没使用）：实时监控过期时间，对内存友好，对 CPU 不友好 定期过期：每隔一段时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已经过期的 key。该策略是前两者的折中方案。通过调整定时扫描的 时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果 Redis 事务实现 事务开始 MULTI 命令的执行，标志着一个事务的开始。MULTI 命令会将客户端状态的 flags 属性中的 REDIS_MULTI 标识打开、 命令入队 当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为 MULTI、EXEC、WATCh、DISCARD 中的一个，立即执行这个命令，否则将命令放入一个事务队列里，然后向客户端返回 QUEUED 回复 如果客户端发送的命令为 EXEC、DISCARD、WATCh、MULTI 四个命令中的一个，那么服务器立即执行这个命令 如果发送到是其他命令，服务器并不立即执行这个命令。首先检查命令格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并返回错误信息给客户端。如果正确，将这个命令放入一个事务队列里，然后返回 QUEUED 回复 事务队列是按照 FIFO 的方式保存入队命令 事务执行 客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑 如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行 否则客户端处于事务状态（flags 有 REDIS_MULTI标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返给客户端 redis 不支持事务回滚机制，但是他会检查每一个事务中的命令是否错误 redis 事务不支持检查程序员自己逻辑的错误 WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令 MULTI 命令用于开启一个事务，它总是返回 OK。MuLTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 被调用时，所有队列中的命令才会被执行 EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态退出 UNWATCH 命令可以取消 WATCH 对所有 key 的监控 Redis 主从复制的核心原理 通过执行 slaveof 命令或设置 slaveof 选项，让一个人服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当昔日操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库\n全量复制 主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化，该过程是非常消耗 CPU、内存（页表复制）、硬盘 IO 的 主节点通过网络将 RDB 文件发送给从节点，对主从节点的带宽都会带来很大的消耗 从节点清空老数据、载入新 RDB 文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行 bgrewriteaof，也会带来额外的消耗 部分复制 复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量 offset 复制积压缓冲区：主节点内部维护了一个固定长度、先进先出 （FIFO）队列作为复制积压缓冲区，当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制 服务运行 ID（runid）：每个 Redis 节点都有其运行 ID，yunxing ID 由节点在启动时自动生成，主节点会将自己运行ID 发送给从节点，从节点会将主节点的运行 ID 存起来。从节点 Redis 断开重连的时候，就是根据运行 ID 来判断同步的进度： 如果从节点保存的 runid 与主节点现在的 runid 相同，说明主从节点之前同步过，主从节点会继续尝试使用部分复制（到底能不呢部分复制还要看 offset 和复制积压缓冲区的情况）； 如果从节点保的 runid 与主节点现在的 runid 不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制 过程原理：\nRedis 有哪些数据结构，有哪些应用场景 字符串：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个 json 格式的字符串，Redis 分布式锁就利用了这种数据结构，还包括可以实现计数器、Session 共享、分布式 ID 哈希表：可以用来存储一些 key-value 对，更适合用来存储对象 列表：Redis 的列表通过命令的组合，既可以当作栈，也可以当作队列来使用，可以用来缓存类似微信公众号、微博等消息流数据 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集等操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能 有序集合：集合是无序的，有序集合可以设置顺序，可以实现排行版功能 Redis 分布式锁底层是如何实现的 首先利用 setnx 来保证：如果 key 不存在才能获取到锁，如果 key 存在，则获取不到锁 然后还要利用 lua 脚本来保证多个 redis 操作的原子性 同时还要考虑到锁过期，所需要额外的一个看门狗定时任务来监听锁是否需要续约 同时还要考虑到 redis 节点挂掉后的情况，所以需要采用红锁的方式来同时向 N/2+1 个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个 redis 节点挂掉了，锁也不能被其他客户端获取到 Redis 集群策略 Redis 提供了三种集群策略\n主从模式：这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连接主库或者某个从库，但是当主库或者从库宕机后，客户端需要手动修改 IP，另外，这种模式也比较男进行扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能支持特大数据量 哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为新发主库，另外哨兵也可以做集群，从而可以保证当某一个哨兵接待你宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证 Redis 集群的高可用，但是仍然不能很好的解决 Redis 的容量上限问题 Cluster 模式：Cluster 模式是用的比较多的模式，它支持多主多从，这种模式会按照 key 进行槽位的分配，可以使得不同的 key 分散到不同的主节点上，利用这种模式可以使得整个集群支持更大达到数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从他的从节点选举一个新的主节点 对于这三种模式，如果 Redis 要存的数据量不大，可以选择哨兵模式，如果 Redis 要存的数据量大，并且需要持续的扩容，那么选择 Cluster 模式\n缓存穿透，缓存击穿，缓存雪崩分别是什么 缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问 Mysql\n缓存雪崩：如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问 Mysql 了，解决办法就是在过期时间增加一点随机值，另外如果搭建一个高可用的 Redis 集群也是防止缓存雪崩的有效手段 缓存击穿：和缓存雪崩类似，缓存雪崩使大批热点数据失效，而缓存击穿是指某一个热点 key 突然失效，也导致了大量请求直接访问 Mysql 数据库，这就是缓存击穿，解决方案就是考虑这个热点 key 不设过期时间 缓存穿透：假如某一时刻访问 Redis 的大量 key 都不存在 Redis 中（如黑客故意伪造的 key），那么也会给数据库造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个 key 不存在，那么这个 key 就肯定不存在，所以可以在缓存之前增加一层布隆过滤器来拦截不存在的 key Redis 和 Mysql 如何保证数据一致 先更新 Mysql 再更新 Redis，如果更新 Redis 失败，可能仍然不一致 先删除 Redis 缓存数据，再更新 Mysql，再此查询的时候将数据加到缓存中，这种方案能解决第一个问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了 Redis 缓存数据，正在更新 Mysql，此时另外一个查询再查询，就会把 Mysql 中的老数据又插到 Redis 中 延时双删，先删除 Redis 缓存数据，再更新 Mysql，延迟几百毫秒再删除 Redis 缓存数据，这样就算在更新 Mysql 时，有其他线程读了 Mysql，把老数据读到了 Redis 中，那么也会被删除，保证数据一致性 Redis 持久化机制 RDB 快照文件，二进制写进磁盘\n手动触发：\nsave 命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用 bgsave 命令，fork 出一个子进程执行持久化，主进程只在 fork 过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了 自动触发：\nsave m n：在 m 秒内，如果有 n 个键发生改变，则自动触发持久化，通过 bgsave 执行，如果设置多个，只要满足其一就会触发，配置文件有默认配置（可以注释掉） flushall：用于清空 Redis 所有的数据库，flushdb 清空当前 Redis 所在数据库（默认是0号数据库），会清空 RDB 文件，同时也会生成 dump.rdb、内容为空 主从同步：全量同步时会自动触发 bgsave 命令。生成 rdb 发送给从节点 优点：\n整个 Redis 只包含一个文件 dump.rdb，方便持久化 容灾性好，方便备份 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以时 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 高性能 相对于数据集大时，比 AOF 的启动效率更高 缺点：\n数据安全低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时可能会导致整个服务器停止服务几百毫秒，甚至一秒钟，会占用 CPU AOF 以日志形式记录服务器所处理的每一个写、删除操作，以文本方式记录，可以打开文件看到详细的操作记录\n所有的写命令会追加到 AOF 缓冲中 AOF 缓冲区根据对应的策略向硬盘进行同步操作 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的 当 Redis 重启时，可以加载 AOF 文件进行数据恢复 同步策略：\n每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失 每修改同步：同步持久化，每次发生的数据变化都会被记录到磁盘中，最多丢失一条 不同步：由操作系统控制，可能丢失较多数据 优点：\n数据安全 通过 append 模式写文件，即使中途服务器宕机也不会劈坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性的问题 AOF 机制的 rewrite 模式。定期对 AOF 文件进行重写，以达到压缩的目的 缺点：\nAOF 文件比 RDB 文件大，恢复速度慢 数据集大的时候，比 RDB 启动效率低 运行效率没有 RDB 高 Redis 单线程为什么这么快 Redis 基于 Reactor 模式开发了网络事件处理器、文件事件处理器 file event handler。它是单线程的，所以 Redis 才叫做单线程的模型\n","date":"2024-09-02T10:17:38+08:00","image":"https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber_hu4745314353014532042.jpg","permalink":"https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/","title":"数据库相关"},{"content":"Spring 谈谈 IOC IOC - 控制反转\n什么是控制，控制了什么 我们在使用 Spring 时，会建一些类，比如 UserService\n使用一些注解，比如 @Autowired\n但是，当程序运行时，用的是具体的 UserService 对象，那么这些对象是什么时候创建的，谁创建的，对象里的值哪里来的，这些都是 Spring 做的\n这就是控制\n控制对象的创建 控制对象内属性的赋值 什么是反转 如果我们不使用 Spring，就需要我们自己创建对象以及赋值，反过来，Spring 帮我们做这些，这就是 反转，表示一种 对象控制权 的转移\n反转有什么用，为什么反转 如果我们自己负责创建对象，自己赋值，会出现什么情况\n比如现在有三个类\nA 类，A 类里有一个属性 C c B 类，B 类里也有一个属性 C c C 类 现在程序要运行，这三个类的对象都要创建出来，并且相应的属性要有值，那么除开定义这三个类，我们还需要写\nA a = new A() B b = new B() C c = new C() a.c = c b.c =c 我们会多些很多业务代码，而且随着属性变多，类变多，代码会变得异常复杂，将这些工作交给 Spring，减轻了程序员的负担\n总结 IoC 表示控制反转，表示如果使用 Spring，那么 Spring 会负责来创建对象，以及给对象内的属性赋值，也就是如果用 Spring，那么对象的控制权将转交给 Spring\n单例 Bean 和单例模式 单例模式表示 JVM 中某个类的对象只会存在一个\n单例 Bean 并不表示 JVM 中只能存在唯一的某个类的对象\n单例 Bean ，使用同一个名字能拿到同一个对象，但我可以 new 出来很多个该对象取不同的名字\nSpring 中的事务是如何实现的 Spring 事务底层是基于数据库事务和 AOP 机制的 首先对于使用了 @Transactional 注解的 Bean，spring 会创建一个代理对象作为 Bean 当调用代理对象的方法时，会先判断该方法上是否加了 @Transactional 注解 如果加了，那么则利用事务管理器创建一个数据库连接 并且修改数据库连接的 autocommit 属性为 false，禁止此连接的自动提交，这是实现 Spring 事务非常重要的一步 然后执行当前方法，方法中会执行 sql 执行完当前方法后，如果没有出现异常就直接提交事务 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务 Spring 事务的隔离级别对应的就是数据库的隔离级别 Spring 事务的传播机制是 Spring 事务自己实现的，也是 Spring 事务中最复杂的 Spring 事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行 sql Spring 事务传播机制 多个事务方法相互调用时，事务如何在这些方法间传播，方法 A是一个事务的方法，方法 A 执行过程中调用了方法 B，那么方法 B 有无事务以及方法 B 对事务的要求不同都会对方法 A 的事务具体执行造成影响，同时方法 A 的事务对方法 B 的事务执行也有影响，这种影响具体是什么就由这两个方法所定义的事务传播类型所决定\nREQUIRED（Spring 默认的事务传播类型）：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务 SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行 MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常 REQUIRED_NEW：创建一个新事物，如果当前存在事务，则挂起该事务 NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务 NEVER：不使用事务，如果当前事务存在，则抛出异常 NESTED：如果当前事务存在，则在嵌套事务中执行，否则开启一个事物 Spring 事务什么时候会失效 spring 事务的原理是 AOP，进行了切面增强，那么失效的根本原因是这个 AOP 不起作用了，常见情况有以下几种\n发生自调用，类里面使用 this 调用本类的方法（this 通常省略），此时这个 this 对象不是代理类，而是 UserService 对象本身 方法不是 public 的：@Transactional 只能用于 public 方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式 数据库不支持事务 没有被 spring 管理 异常被吃掉事务不会回滚（或抛出的一场没有被定义，默认 RuntimeException） Spring 中 Bean 是线程安全的吗 Bean 本质上还是一个对象\nSpring 本身没有针对 Bean 做线程安全的处理，所以\n如果 Bean 是无状态的，那么 Bean 是线程安全的 如果 Bean 是有状态的，那么 Bean 是线程不安全的 （有状态：Bean 里的属性会变化，Setter方法）\n另外，Bean 是不是线程安全，跟 Bean 的作用域没有关系，Bean 的作用域只是表示 Bean 生命周期范围，对于任何生命周期的 Bean 都是一个对象，这个对象是不是线程安全的，还是得看这个 Bean 对象本身\nSpring 中的 Bean 创建的生命周期有哪些步骤 推断构造方法 实例化 填充属性（依赖注入） 处理 Aware 回调 初始化前，处理 @PostConstruct 注解 初始化，处理 InitializingBean 接口 初始化后，进行 AOP ApplicationContext 和 beanFactory 有什么区别 BeanFactory 是 Spring 中非常核心的组件，表示 Bean 工厂，可以生成 Bean，维护 Bean，而 ApplicationContext 继承了 BeanFactory，所以 ApplicationContext 拥有 BeanFactory 所有的特点，也是一个 Bean 工厂，但是 ApplicationContext 除开继承了 BeanFactory 之外，还继承了诸如 EnvironmentCapable、MessageSource、ApplicationEventPublisher 等接口，从而 ApplicationContext 还有获取系统环境变量、国际化、事件发布等功能，这是 BeanFactory 所不具备的\n1 public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver 这里 ApplicationContext 不仅继承了 ListableBeanFactory，还继承了环境变量操作的接口\nEnvironmentCapable ，国际化 MessageSource 等接口\nSpring 容器启动流程是怎样的 在创建 Sprig 容器，也就是启动 Spring 时 首先会进行扫描，扫描得到所有的 BeanDefinition 对象，并存在一个 Map 中 然后筛选出非懒加载的单例 BeanDefinition 进行创建 Bean，对于多例 Bean 不需要再启动过程中去进行创建，对于多例 Bean 会在每次获取 Bean 时利用 BeanDefinition 去创建 利用 BeanDefinition 创建 Bean 就是 Bean 的创建生命周期，这期间把包括了合并 BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中 AOP 就是发生再初始化后这一步骤中 单例 Bean 创建完了之后， Spring 会发布一个容器启动事件 Spring 启动结束 在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些 BeanFactoryPostProcessor 和 BeanPostprocessor 的注册，Spring 的扫描就是通过 BeanFactoryPostProcessor 来实现的，依赖注入就是通过 BeanPostprocessor 来实现的 在 Spring 启动过程中还回去处理 @Import 等注解 Spring Boot 中常用注解及其底层实现 @SpringBootApplication 注解：这个注解标识了一个 SpringBoot 工程，它实际上是另外三个注解的组合 @SpringBootConfiguration：这个注解实际上就是以恶搞 @Configuration，表示启动类也是一个配置类 @EnableAutoConfiguration：向 Spring 容器中导入了一个 Selector，用来加载 ClassPath 下 SpringFactories 中所定义的自动配置类，将这些自动加载为配置 Bean @ComponentScan：标识扫描路径，因为默认是没有配置实际扫描路径，所以 SpringBoot 扫描的路径是启动类所在的当前目录 @Bean 注解：用来定义 Bean，类似于 XML 中的 标签，Spring 在启动时，会对加了 @Bean 注解的方法进行解析，将方法的名字作为 beanName，并通过执行方法得到 bean 对象 @Controller、@Service、@ResponseBody、@Autowired Spring Boot 是如何启动 Tomcat的 首先，SpringBoot 在启动时会先创建一个 Spring 容器 在创建 Spring 容器过程中，会利用 @ConditionalOnClass 技术来判断当前 classpath 中是否存在 Tomcat 依赖，如果存在则会生成一个启动 Tomcat 的 Bean Spring 容器创建完后，就会获取激动 Tomcat 的 Bean，并且创建 Tomcat 对象，并绑定端口等，然后启动 Tomcat ","date":"2024-08-30T17:59:49+08:00","image":"https://akaxedx.github.io/p/spring/saber_hu3822888719987798397.jpg","permalink":"https://akaxedx.github.io/p/spring/","title":"Spring"},{"content":"计算机基础 计网 计网定义 一些互相连接的自治的计算机的集合\n1 2 3 4 5 互联：是指计算机之间可以通过有线或者无线的方式进行数据通信 自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用 集合：是指至少需要两台计算机 中国的三大 ISP ：中国电信，中国联通，中国移动\n一旦某个用户能够接入到因特网，所需要的就是购买一些如调制解调器或路由器这样大设备，让其他用户可以和他相连\n网络协议三要素 语法、语义、同步\n1 2 3 4 5 语法：用户数据与控制信息的结构和格式 语义：需要发出控制信息，以及完成的动作与做出的响应 同步：可以理解为时序，即对时间实现顺序的详细说明 三种交换方式 路由器 是实现 分组交换 的关键构件，其任务是 转发 收到的分组，这是网络核心部分最重要的功能\n传统两两相连的方式，当电话数量很多时，电话线也很多，不方便\n电路交换 电话交换机接通电话线的方式就是电路交换 分组交换 1 2 3 4 5 通常我们把表示该消息的整块数据称为一个报文 在发送报文之前，先把较长的报文划分成一个个更小的等长数据段，在每一个数据段前面，加上一些由必要的控制信息组成的 首部，就构成了一个分组，也可以称为 “包” 首部包含了分组的目的地址 发送过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 发送方 构造分组 发送分组 路由器 缓存分组 转发分组 简称为 “分组转发” 路由器处理分组的过程： 把收到的分组先放入缓存（暂时存储） 查找转发表，找出到某个目的地地址应从哪个端口转发 把分组送到适当的端口转发出去 接收方 接收分组 还原报文 报文交换 1 2 报文交换中的结点页采用存储转发方式，但报文交换，对报文的大小没有限制，这就要求 结点交换机需要较大的缓存空间 报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代 三种交换方式的对比 假设 A B C D 是分组传输路径所要经过的 4 个结点交换机，纵坐标为时间\n按覆盖范围分类 广域网（WAN） 1 作用范围通常为几十到几千公里，因而又是也称为远程网。广域网是互联网的核心部分，其任务是通过 长距离 运送主机所发送的数据 城域网（MAN） 1 作用范围一般是一个城市，可跨越几个街区 甚至是整个城市 局域网（LAN） 1 一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右） 个域网（PAN） 1 就是在个人工作的地方把个人使用的 电子设备 用 无线技术 连接起来的网络 按拓扑结构分类 总线型网络 星型网络 环形网络 网状型网络 计算机网络的性能指标 速率 传送比特的速率，也成为比特率或者数据率\n带宽 网络的通信线路所能传送数据的能力\n单位：Hz\n吞吐量 在单位时间内通过某个 信道 的数据量\n时延、等等 按传输介质分类 有线网络 无线网络 常见计算机网络体系结构 【计算机网络】的体系结构是 计算机网络的各层及其协议的集合\n如今使用的最多的是 TCP/IP 体系结构，新进闺蜜最大的，覆盖全球的\n大概流程 物理层 就是解决在各种传输媒体上传输比特 0 和 1 的问题，进而给数据链路层提供 透明传输比特流的服务\n主要由以下四个任务 机械特性：指明所有接线器的形状和尺寸。引脚数目和排列、固定和锁定装置 电气特性：指明在接口电缆的各条线上出现的电压的范围 功能特性：指明某条线上出现的某一电平的电压表示何种意义 过程特性：指明对于不同功能的各种可能事件的出现顺序 传输媒体分为两类：引导型传输媒体，非引导型传输媒体\n引导型传输媒体：通轴电缆、双绞线、光纤、电力线 非引导行传输媒体：无线电波、微波、红外线、可见光 传输方式 串行传输 数据是一个比特一个比特依此发送的，只需要一条数据传输线路\n并行传输 一次发送 n 个比特，需要 n 条传输线路\n同步传输 1 数据块以稳定的比特流形式传输，字节之间没有间隔，接收端在每个比特的中间时刻进行检测，以判别接收到的比特 0 或是比特 1 异步传输 1 以字节为独立的传输单位，字节之间的时间间隔是不固定的，在每个字节的前后分别加上起始位和结束位 单向通信 又称单工通信，通信双方只有一个传输方向\n双向交替通信（半双工） 可以互相传输数据，但是不能同时进行\n双向同时通信（双工） 通信双方可以同时发送和接收消息\n码元 简单来说 码元 就是一段调制好的 基本波形 ，可以表示比特信息\n编码、调制 信号失真 1 信号在传输过程中会受到各种因素的影响，是的信号波形失去码元之间的清晰界限，这种现象称为 码间串扰 1 2 3 4 5 造成信号失真的因素 码元传输速率 信号传输距离 噪声干扰 传输媒体质量 奈氏准则 奈氏准则 是理想条件下推导的，没有考虑传输距离、噪声干扰等因素\n香农公式 数据链路层 概述 链路 是从一个 结点到相邻结点 的一段 物理线路 ，数据链路 则是在 链路的基础 上增加了一些必要的 硬件（如网络适配器）和软件（如协议的实现）\n数据链路层传送的协议数据单元是 帧\n封装成帧 封装成帧 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧 首部和尾部的一个重要的作用就是进行 帧定界 透明传输 如果数据中的某个字节的 二进制代码恰好和 SOH 或 EOT 一样，数据链路就会 错误地“找到帧的边界”\n解决透明传输的方法\n1 面向 字节的物理链路 使用 字节填充，面向 比特的物理链路 使用 比特填充 的方式实现透明传输 发送端的数据链路层在数据中出现控制字符 “SOH” 或 “EOT” 的前面 插入一个转义字符“ESC”\n差错检测 比特在传输过程中可能会产生差错，1可能变成0，0可能变成1，这就称为比特差错\n差错检测法 奇偶校验 只能检测出奇数个比特出现错误码的情况\nCRC 集线器 集线器是运作在 OSI 模型中的 物理层 ，可以是做多端口的【中继器】\n交换机 也叫做　交换式集线器，它通过对信息进行重新生成，并经过内部处理后　转发至指定端口，具备自动寻址能力和交换作用，在数据链路层\n集线器和交换机的区别 集线器平分带宽，交换机的话也是　３Ｍ\n最初　的　以太网　是将许多计算机都连接到同一根总线上\nCSMA/CD 【CSMA/CD】即 冲突检测 的 载波监听多路访问 的方法\n三大要点 多点接入：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上 载波监听：用电子技术检测总线上有没有其他计算机也在发送 碰撞检测：即适配器便发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据 PPP 点对点协议，为在点对点连接上传输多协议数据包提供了一个标准方法，为两个对等节点之间的 IP 流量传输提供一种 封装协议\n广播域 指网络中的某一设备同时向 网络中所有的其他设备发送数据，这个数据所能 广播到的范围 即为广播域\n冲突域 多少 站点能抽到这个信息，这些站点就构成一个冲突域\n交换机 所有端口都在同一个广播域内，而每一个端口就是一个冲突域，所以交换机能分割冲突域，但分割不了广播域 。但是，虚拟局域网（Vlan） 技术的交换机可以 隔离广播域\nA 发消息 BC 都能收到\nVLAN 虚拟局域网 VLAN 是由一些局域网网段构成的 与物理位置无关的逻辑组\n同一个 VLAN 内部可以广播通信，不同 VLAN 不可以广播通信 接口划分方式 1 2 3 4 5 6 1、Access 接口 Access 接口一般用于和不能识别 Tag 的用户终端（如用户主机、服务器等）相连，或者不需要区分不同 VLAN 成员时使用 2、Trunk 接口 Trunk 接口一般用于连接交换机、路由器、AP 以及可以同时收发 Tagged 帧和 Untagged 帧的语音终端 3、Hybrid 接口 Hybrid 接口既可以用于连接不能识别 Tag 的用户终端，也可以用于连接交换机、路由器以及可以同时收发 Tagged 帧和 Untagged 帧的语音终端、AP 所属 VLAN 允许通过 VLAN access 只能一个（即划入的 VLAN） 只能一个即划入的 VLAN trunk 只能一个 （即 pvid） 任意个 MAC 地址 MAC 地址是一个 唯一标识符，有助于在任何网络上识别您的机器\nARP 地址解析协议 IP 地址解析为以太网 MAC\n1 当主机或其他网络设备由数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即 IP地址）。但是仅仅由 IP 地址是不够的，因为 IP 数据报必须封装成帧才能通过物理网络发送，因此发送站还必须由接收站的地址，所以需要一个从 IP 地址到物理地址的映射 网络层 作用 确定在本路由器如何转发分组，确定分组从源到目的经过的路径，是 点到点 服务\nIP （网际协议） IP 地址\n1 2 ipv4：32位\t二进制\t192.168.100.1\t主流 ipv6：128位\t十六进制\tffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\t在使用，未来会普及 IP 地址的组成\n1 2 3 网络号 + 主机号 network + host 网络号：用来标识一个网段\n主机号：用来标识这个网段上的某一台主机\nIP 地址的分类\nA 类 1 2 3 网络号.主机号.主机.主机 第一个可指派的网络号位1，网络地址为 1.0.0.0 最后一个可指派的网络号为 126 网络地址为 126.0.0.0 1 2 3 4 5 6 可指派的网络号：2^(8-1) - 2 减2的原因是除去最小网络号0和最大网络号127 127.0.0.1 回环地址，用来在每台计算机测试 tcp/ip 协议使用，只能在本机访问，别人不允许访问 可分配的 ip 地址共有：2^24 - 2 、 其中减去的为全为0的网络地址和全为1的广播地址 B 类 1 2 3 4 5 6 128 ~191 网络号.网络号.主机.主机 最小网络号也是第一个可指派的网络号128.0网络地址为128.0.0.0 最大网络号也是最后一个可指派的网络号191.255网络地址为191.255.0.0 可指派的网络号：2^(16-2)-2 可分配的 ip 地址共有：2^16-2个 C 类 1 2 3 4 5 6 7 8 192 ~223 网络号.网络号.网络号.主机 最小网络号也是第一个可指派的网络号192.0.0网络地址为192.0.0.0 最大网络号也是最后一个可指派的的网络号223.255.255网络地址为223.255.255.0 2^(24-3) -2 2^8 -2 个 公网上使用ABC三类地址\nD 类 1 224 ~ 组播地址 E 类 保留给科学家使用\n有人提出是否可以从主机号部分借用一部分作为子网号\n所以就有了一个划分子网的工具：子网掩码\n从1985 年起 在 IP 地址中 又 增加了一个“子网号字段”，使两级的 IP 地址变为三级的 IP 地址\nCIDR 无类域间路由选择\n消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间\n即在 IP 地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数\n1 192.168.1.0/22 子网掩码概念\n子网掩码可以表明分类 IP 地址的主机号部分被借用了几个比特做为子网号\n如何划分子网 从 主机号 借用若干个为 作为子网号 subnet-id，而主机号，也就相应减少了若干个位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 网络地址：网络号 + 子网号 + 主机号（全为0） 广播地址：网络号 + 子网号 + 主机号 （全为1） 子网掩码：网络号（全为1） + 子网号（全为1） + 主机号（全为0） IP 地址总数：根据主机号的位数进行确定 可分配 IP 地址数：IP 地址总数 - 2（去除主机号全为0的网络地址和主机号全为1的广播地址） 可分配 IP 地址范围：就是子网地址 + 1 ~ 广播地址 - 1 A 类地址 网络号8位主机号24位\t地址范围是1.0.0.0~126.0.0.0 B 类地址 网络号16位主机号16位\t地址范围是128.0.0.0~191.255.0.0 C 类地址 网络号24位主机号8位\t地址范围是192.0.0.0~223.255.255.0 划分子网是从主机号中借位进行划分的 子网划分方式有两种\t①定长子网划分\t②可变长子网划分 直接交付和间接交付 如果 目的网络地址和源 网络地址相同，就是在 同一个网络中，属于直接交付\n如果 目的网络地址和源 网络地址不相同，就 不在同一个网络中，属于间接交付， 通常是一个路由器帮忙转发\n类型 1 2 3 直连网络 静态路由（人工配置） 动态路由（路由选择协议） 如何判断是不是同一个网段 创建 vlan1：ip 地址：192.168.1.1 子网掩码：255.255.255.0\n创建 vlan2：ip 地址：192.168.2.1 子网掩码：255.255.255.0\n那么他们是不是在同一个网段呢\n​\t详细计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 将 ip 地址 192.168.1.1 转为二进制 11000000 10101000 00000001 00000001 将子网掩码 255.255.255.0 转为二进制 11111111.11111111.11111111.00000000 然后将两者与运算 11000000 10101000 00000001 00000001 11111111.11111111.11111111.00000000 得到 11000000 10101000 00000001 00000000 转成网络号是 192.168.1.0 将 ip 地址 192.168.2.1 转为二进制 11000000 10101000 00000010 00000001 将子网掩码 255.255.255.0 转为二进制 11111111.11111111.11111111.00000000 然后将两者与运算 11000000 10101000 00000010 00000001 11111111.11111111.11111111.00000000 得到 11000000 10101000 00000010 00000000 转成网络号是 192.168.2.0 不是一个网段 传输层 概念 IP 层是实现点到点的连接\n传输层是提供【端到端】的连接，即实现不同进程之间的通信\n在传输层主要依赖 TCP 和 UDP 协议，TCP 是一种可靠的、面向连接的通信协议。UDP 是一种不可靠、无连接的通信协议\nTCP TCP 报文结构 1 2 3 4 5 6 7 8 9 10 11 12 源端口号：发送数据进程的端口号，范围0~65525 目标端口号：接收数据进程的端口号，范围0~65525 序列号：序列字段的值指的是本报文段所发送的数据的第一个字节的序号 确认号：期望收到对方的下一个报文段的数据的第一个字节的序号 URG：紧急比特，当 URG = 1 时，表明紧急指针字段有效，它告诉系统此报文中有紧急数据应尽快传送（相当于高优先级的数据） ACK：确认比特，只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效 PSH：推送比特，接收方 TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付 RST：复位比特，当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新尽力运输连接 SYN：同步比特，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文 FIN：终止比特，用来释放一个连接。当 FIN = 1 时，表明此报文段的发送端的数据已经发送完毕，并要求释放运输连接 三次握手 四次挥手 TCP 流量控制 TCP 拥塞控制 1 TCP 进行拥塞控制的算法有四种，即慢开始、拥塞避免、快重传和快恢复 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 （1）慢开始算法 在 TCP 刚刚连好并开始发送 TCP 报文段时，先令拥塞窗口 cwnd = 1，使用慢开始算法后，每经过一个传输轮次（即往返时延 RTT），拥塞窗口 cwnd 就会加倍，即 cwnd 的大小指数式增长。这样，慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh（阈值），然后改用拥塞避免算法 （2）拥塞避免算法 拥塞避免算法的做法如下：发送端的拥塞窗口 cwnd 没经过 一个往返时延 RTT 就增加一个 MSS 的大小，而不是加倍，使 cwnd 加法增大 · 当 cwnd \u0026lt; ssthresh 时，使用慢开始算法 · 当 cwnd \u0026gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法 · 当 cwnd = ssthresh 时，既可以使用慢开始算法，又可以使用拥塞避免算法（通常做法） 网络拥塞的处理 网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，把慢开始门限 ssthresh 设置为出现拥塞时发送方的 cwnd 值的一半（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法 （3）快重传 在 TCP 可靠传输机制中，快重传技术使用了冗余 ACK 来检测丢包的发生，在某些情况下可更早地重传丢失的报文段。当发送方连续收到三个重复的 ACK 报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时 （4）快恢复 发送端收到连续三个冗余 ACK （即重复确认）时，执行“乘法减小”算法，把慢开始门限 ssthresh 设置为出现拥塞时发送方 cwnd 的一半，慢开始算法将拥塞窗口 cwnd 设置为 1，但是它设置为 ssthresh / 2 的值开始，由于跳过了 cwnd 从 1 起始的慢开始过程，所以称为快恢复 UDP UDP 报文结构 1 2 3 4 源端口号：通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中。如果不写入端口号，则把这个字段设置为0。这样，接收端的应用程序就不能发送响应了 目标端口号：接收端计算机上 UDP 软件使用的端口 长度：表示 UDP 数据报长文，包含 UDP 报文头和 UDP 数据长度 校验和：检验数据在传输过程中是否被损坏 TCP 和 UDP 的区别 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅 8 字节 首部最小 20 字节，最大 60 字节 适用场景 适用于实时应用（IP 电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 端口 TCP 端口是指就是为 TCP 协议通信提供服务的端口。在 TCP 传输控制协议中，建立端对端的连接是靠 IP 地址和 TCP 的端口号的共同作用。UDP 端口是指就是为 UDP 协议通信提供服务的端口\n端口号的范围是从 1~65535，一般分为 3 类端口：熟知端口号，登记端口号，客户端口号或短暂端口号\n熟知端口号：数值一般为0~1023，每个端口号应用于特定熟知的应用协议\n登记端口号：数值为 1024~49151，为没有熟知端口号的应用程序使用的，使用这个范围的端口号必须在 IANA 互联网数字分配机构登记，以防止重复\n客户端口号或短暂端口号：数值为 49151~65535，留给客户进程选择暂时使用\n常见端口列表\n应用层 网络应用模型 客户/服务器模型 服务器：系统启动后，便不断运行，被动等待并接受来自客户机的请求 客户机：请求计算服务的主机 P2P 模型 1 2 3 在 P2P 模型中，任意一对计算机称为对等方（Peer），直接相互通信 在对等网络中上的每台计算机具有相同的功能，没有主从之分，没有专用服务器，也没有专用工作站，任何一台计算机既可以作为服务器，又可以作为工作站 1 在 P2P 中，随着用户不断加入，服务需求的不断增加，系统的整体资源和服务能力得以同步扩充和提高。新用户的加入可以提供服务和资源，更好地满足了网络中用户的需求，促进分布式体系的实现 DNS 域名系统：便于把具有特定含义的主机名转换为便于机器处理的 IP 地址\n分类 包括顶级域名，二级域名，三级域名等\n1 2 3 4 5 6 以 tieba.baidu.com为例 正确的域名划分为 .com 顶级域名/一级域 baidu.com\t二级域名 tieba.baidu.com\t三级域名 detail.tieba.baidu.com\t四级域名 1 2 3 4 递归查询和迭代查询的区别： 递归查询是一种 DNS 服务器的查询模式，在该模式下 DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果 DNS 服务器本地没存储查询 DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机 迭代查询 DNS 服务器是另外一种查询模式，DNS 服务器会向客户机提供其他能够解析查询请求的 DNS 服务器，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机再向这台 DNS 服务器提交请求，依此循环直到返回查询的结果 几个重要的协议 1 2 3 4 5 6 7 8 9 1、远程登录协议（Telnet） 2、文件传输协议（FTP） 3、超文本传输协议（HTTP） 4、域名服务协议（DNS） 5、简单邮件传输协议（SMTP） 6、邮局协议（POP3） 其中，从网络上下载文件时使用的是 FTP 协议，上网浏览网页时使用的是 HTTP 协议 在网络上访问一台主机时，通常不直接输入 IP 地址，而是输入域名，用的时 DNS 服务协议，它会将域名解析为 IP 地址 通过 FoxMail 发送电子邮件时，使用 SMTP 协议，接收电子邮件时使用 POP3 协议 万维网 概述 概念：万维网 是 超大规模，联机形式的 资料空间，是 海量网络站点和网页集合 定位资源：使用 统一资源定位符 URL 可以唯一标识一个资源，这个资源可以是文本，视频，音频，图片 URL 形式：\u0026lt;协议\u0026gt;://\u0026lt;主机地址\u0026gt;:\u0026lt;端口号\u0026gt;/\u0026lt;路径\u0026gt; 1 2 3 4 协议：http，ftp 主机地址：IP 地址， 域名 端口号：16 位端口号，0~65535 URL 不区分大小写字母 获取资源：用户点击超链接获取资源， 服务器通过 HTTP 协议 将资源传输给用户 万维网工作方式：客户端/服务器 方式，客户端就是网页浏览器 IE，火狐等，服务器是部署 HTTP 服务器程序，如 Tomcat，IIS HTTP 定义了 浏览器 向 服务器 请求资源的方式，以及 服务器 如何将资源 发送给浏览器，具体流程如下\n1 2 3 4 5 6 7 8 9 （1）用户操作：用户 在浏览器上 输入 URL，或点击超链接 （2）分析 URL：浏览器 分析 URL 链接 （3）请求 IP 地址：浏览器向 DNS 服务器请求域名对应的 IP 地址 （4）解析 IP 地址：DNS 服务器将域名解析成 IP 地址 （5）建立 TCP 连接：客户端与服务器端建立 TCP 连接 （6）浏览器申请资源：浏览器向服务器发出申请资源命令 （7）服务器响应：服务器响应浏览器的资源申请 （8）释放 TCP 连接：客户端服务器双方释放 TCP 连接 （9）浏览器显示资源：浏览器显示从服务器中获取到的文本，图片，视频等资源 请求报文 请求报文的格式由 请求行+请求头+请求体 构成\n请求行：\n请求方法 + 请求 URL + Http 协议版本\n请求方法：常见的 HTTP 请求方法有 GET，POST 还有 DELETE、HEAD、OPTIONS、PUT、TRACE 等方法\n请求行示例：\n1 POST /s?ie=utf-8 HTTP/1.1 请求头：\n常见的请求头\n1 2 3 4 5 6 7 8 9 10 11 12 13 User-Agent: 浏览器类型 Accept: 客户端可识别的响应内容类型列表 Accept-Language: 客户端可接收的自然语言 Accept-Encoding: 客户端可接收的编码压缩格式 Accept-Charest:可接受的应答字符集 Host: 请求的主机名 onnection: 连接方式（close 或 keepalive） Cookie: 存储与客户端扩展字段，向同一域名的服务器端发送属于该域的 cookie content-type: 响应类型 Host: baidu.com Cookie: name=study content-type: application/x-www-form-urlencode User-Agent: chorm 83 请求体：\n1 2 get 方式请求体位空 post 方式的请求体可以不为空（JSON） 响应报文：\n响应报文的格式也是由响应行+响应头+空行+响应体构成\n响应行：报文协议版本 + 状态码 以及状态描述\n1 HTTP/1.1 200 OK 常见 HTTP 状态码\n分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求过程中发生了错误 1 2 3 4 200 - 请求成功 301 - 资源 被永久转移到其他 URL 404 - 请求的资源不存在 500 - 内部服务器错误 HTTPS 1 2 3 4 https 和 http 的区别 （1）https 的端口是443，http 的端口是80，且两者的连接方式不同 （2）http 传输是明文的，而 https 是用 ssl 进行加密的，https 的安全性更高 （3）https 是需要申请证书的，http 不用 计网知识点补充 HTTP/1.1\tHTTP/2\tHTTP/3 的区别 HTTP/1.1 HTTP/1/1 是互联网第一个真正意义的 HTTP 标准版本\n核心是 一次一份\n1 2 3 当获取响应后，才可以发送下一个 HTTP 请求 在 TCP 连接建立之后，我们获取 html 文件，依据 html 文件获取 css、js 等文件 这些过程都是一次一次请求的，当其中一个文件请求失败，后续的文件也就拿不到了 这就是 HTTP 队头阻塞 HTTP1.1为了解决 队头阻塞问题，使用了 管线化 技术，即一个连接中可以发送多个请求，但是 响应的时候也必须按照发送的顺序接收 ，浏览器基本不用\n开发者为了减少请求次数，也开发出了很多黑科技，比如 精灵图 ，base64 直接传字符串\nHTTP/2 核心是 多路复用\n单个 TCP 连接就可以进行交错发送请求和响应\n1 2 3 把原本 HTTP 报文的首部和实体拆为两个部分 - 首部帧，数据帧 有一个流标识符来进行组合，实现了交错发送请求和响应，不会响应错乱 帧类型也可以设置优先级 HTTP/1 对实体进行了压缩，而 HTTP/2 对首部也进行了压缩，使用了 HPACK 算法\n服务器推送\n当浏览器进行请求时，服务器可以不用像以往一样解析 HTML 后再一个一个响应，而是把浏览器后续所需要的文件全发过来。但是存在安全隐患，如果只是点错了网页，就会被大量推送文件，非常臃肿\nHTTP/3 HTTP/2 只解决了 HTTP/1 的队头阻塞，但是 TCP 层面的 队头阻塞依然存在，数据再传输层发生了 丢包，仍然是继续等待\n核心是 整合\nHTTP/3 把 TCP 和 TLS 的握手过程整合在了一起，减少来回开销\nQUIC 协议 整合了 TCP 和 TLS\n所以 HTTP/3 默认使用了加密的，所以可以说是 TCP2.0 但不是 UDP2.0\n应用层过来的数据会被 QUIC 封装成 帧，和 HTTP/2 的帧很像，也是有流标识符\n而 HTTP/3 应用层 中并没有使用帧，而是直接移到了 QUIC 中，从源头解决了 队头阻塞\nQUIC 帧 后续被合成 QUIC 数据包，加入连接 ID，即使网络 IP 发生变化，也可以使用 连接ID 重新连接，避免握手\nQUIC 帧的内容也是被加密的，最后被 UDP 分装从数据段\n","date":"2024-08-29T20:13:09+08:00","image":"https://akaxedx.github.io/p/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/saber_hu3120267142170166617.jpg","permalink":"https://akaxedx.github.io/p/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/","title":"计网基础"},{"content":"Tomcat Tomcat 中为什么要使用自定义类加载器 一个 Tomcat 中可以部署很多个应用，而每个应用中都存在很多类，各个应用中的类是独立的，全类名是可以相同的。一个 Tomcat 不管内部部署了多少应用，Tomcat 启动之后就是一个 Java 进程，也就是一个 JVM，所以如果 Tomcat 中只存在一个类加载器，比如默认的 AppClassLoader，那么只能加载一个同名类，这是有问题的。在 Tomcat中，会为部署的每个应用都生成一个类加载器实例，叫做 WebAppClassLoader，这样 Tomcat 中每个应用都可以使用自己的类加载器去加载自己的类，实现应用之间的类隔离，不出现冲突。另外 Tomcat 还利用自定义加载器实现了热加载的功能\n","date":"2024-08-25T18:10:13+08:00","image":"https://akaxedx.github.io/p/tomcat/saber_hu18427175924411022449.jpg","permalink":"https://akaxedx.github.io/p/tomcat/","title":"Tomcat"},{"content":"Java 基础 JUC =================================\n更新于 2024.9.5，旧版在淘汰文章中可以查看\n=================================\n什么是锁 在并发环境下，多个线程会对同一个线程进行争抢，可能会导致数据不一致，为了解决这一问题，很多编程语言都引入了锁机制，通过一种抽象的锁对资源进行锁定\nJava 锁机制 红色区域各个线程私有的，蓝色是公有的，私有部分不会导致线程安全问题，而蓝色区域被所有线程共享，需要锁机制来进行限制，锁是一种抽象的概念，Java 是怎么实现的？\nJava 对象结构 实例数据 初始化所设置的属性方法等内容\n填充字节 为了满足 Java 对象是 8 bit 的倍数所设计的，填充的无用字节\n对象头 Class Point：指针，指向当前对象类型所在方法区中的类型数据 Mark Word：存放了和当前对象运行时状态有关的数据 Synchronized 关键字 编译后生成字节码指令 monitorenter 和 monitorexit 来管控线程\nMonitor -\u0026gt; 管程、监视器\n当一个线程进入 monitor，其他线程只能等待，下图为重量级锁的机制\n为了避免切换内核态的时间超过运行程序时间，Java 对 Synchronized 进行了优化\n升级过程 无锁：\n无竞争，直接调用 存在竞争，使用非锁方式同步线程，这就是 CAS，CAS 在操作系统中通过一条命令保证原子性 偏向锁：\n一个对象被加锁了，但实际运行时只有一个线程会获取这个锁，理想状态我们不通过线程状态切换，也不通过 CAS 来获取锁，因为多多少少会浪费资源。我们让这个对象认识这个线程，直接交出资源即可。 实现方式：如果当前锁标志位为 01，那么判断倒数低 3 个 bit 是否为 1，如果为 1，于是读取 前 23 个 bit，这 23 个bit 就是线程 ID，通过对比当前线程 ID 和存放的线程 ID 是否相同，假如发生了变化，不止一个线程在使用这个对象，则从偏向锁升级成轻量级锁 轻量级锁：\n实现方式：当前锁标志位为 00，则在**虚拟机栈（线程私有）**中开辟 Lock Record 空间，线程通过 CAS 去尝试获取锁，一旦获得，就会复制对象头中的 Mark Word 到 Lock Record 中，并将 Lock Record 中的 Owner 指针指向该对象，另一方面，Mark Word 的前 30 个 bit 生成一个指针，指向线程虚拟机栈中的 Lock Record，这样实现了线程和对象锁的绑定 其他线程来了：其他线程自旋等待，自旋可以理解为一种轮询，线程不断地循环尝试获取目标对象的锁，如果锁释放了就获取，没释放就继续下一轮循环。不同于操作系统挂起，如果线程很快的就能获取到锁，那么就不需要线程中断和恢复，效率更高。自旋相当于 CPU 空转，如果长时间空转，会浪费 CPU 资源，于是出现了 适应性自旋的优化，自旋次数不再固定，而是视上一次在同一锁上自旋获取锁的情况而动态变化的 自旋等待的线程超过一个或等待时间过长，轻量级锁将升级为重量级锁，将通过 monitor 来进行控制资源，资源将被完全锁定，线程将被挂起等待 CAS 上面的部分多次提到了 CAS，CAS 究竟是什么\n当多个线程来操作资源时，我们第一反应就是使用 互斥锁，但互斥锁是 悲观的\n悲观锁 操作系统将悲观的认为如果不严格同步线程的调用，那么系统是一定会出问题的，互斥锁将完全锁定资源，不允许其他线程调用。这种同步机制就是悲观锁\n但是在读操作多，或者同步代码块执行的耗时远远小于线程切换的耗时时，就本末倒置了，于是不想使用互斥锁，那么如何解决？CAS 就此诞生\nCAS（compare and swap） 比较然后交换\n原理： 资源对象将有一个状态值标记，为 0 可以获取，为 1 正被占用 A 线程 B 线程 同时调用该资源对象，他们都读取到了该资源对象的状态值为 0，于是各自生成两个值，oldValue：之前读到的资源对象的状态值，newValue：代表想要将资源对象的状态值更新后的值 A 抢到时间片，将 oldValue 与资源对象的状态值进行 compare，发现一致，于是 swap 为 newValue，B 线程后来 compare 时发现不一致，放弃 swap，进行自旋 缺陷： 由于没有进行任何线程同步，在 A 线程 swap 的一瞬间，B 抢到时间片，也进行 swap，A B 线程同时获取资源 所以 compare 和 swap 必须被绑定，同时只能用一条线程可以操作，也就是必须保证 CAS 原子性 解决方法： 不同架构的 CPU 都提供了指令级别的 CAS 原子操作，在 x86 架构下，通过 cmpxchg 指令支持 CAS，在 ARM 架构下，通过 LL/SC 实现 CAS，不需要通过操作系统的同步原语（mutex），CPU 已经原生地支持了 CAS，上层可以直接调用 由于不会锁定资源，且认为线程需要修改对象资源的时候乐观认为对象状态值没有被其他线程修改过，而是每次自己主动尝试去 compare 状态值，因此也被称为 乐观锁，所以 乐观锁 其实是无锁同步机制\nJava 如何利用 CAS 特性进行无锁编程 一个需求，多线程打印 0 到 1000\n无锁： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LambdaThread { static Integer num = 0; public static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { Thread t = new Thread(new Runnable() { @Override public void run() { while (num \u0026lt; 1000) { System.out.println(\u0026#34;thread name:\u0026#34; + Thread.currentThread().getName() + \u0026#34; :\u0026#34; + num++); } } }); t.start(); } } } 互斥锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class LambdaThread { static Integer num = 0; public static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { Thread t = new Thread(new Runnable() { @Override public void run() { synchronized (LambdaThread.class) { while (num \u0026lt; 1000) { System.out.println(\u0026#34;thread name:\u0026#34; + Thread.currentThread().getName() + \u0026#34; :\u0026#34; + num++); } } } }); t.start(); } } } 乐观锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LambdaThread { static AtomicInteger num = new AtomicInteger(0); public static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { Thread t = new Thread(new Runnable() { @Override public void run() { while (num.get() \u0026lt; 1000) { System.out.println(\u0026#34;thread name:\u0026#34; + Thread.currentThread().getName() + \u0026#34; :\u0026#34; + num.incrementAndGet()); } } }); t.start(); } } } AtomicInteger 内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\u0026#34;value\u0026#34;)); } catch (Exception ex) { throw new Error(ex); } } .......... public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } } getAndAddInt： 1 2 3 4 5 6 7 public final int getAndAddInt(Object o, long offset, int delta) { int v; do { v = getIntVolatile(o, offset); } while (!compareAndSwapInt(o, offset, v, v + delta)); return v; } do while 就是自旋，默认 10 次\ncompareAndSwapInt： 1 2 3 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 被 native 修饰，底层 C++\nUnsafe： AQS AbstractQueuedSynchronizer\n成员属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED. */ private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. */ private transient volatile Node tail; /** * The synchronization state. */ private volatile int state; state 不为 boolean 的原因： 线程获取锁的两种模式 独占模式：一旦被占用，其他线程不能占用 共享模式：一旦被占用，其他共享模式下的线程能占用 所以需要使用 int 来表示占用的数量 头尾节点 线程在当前时刻没有获取到共享资源，可以选择进行排队 这个队列的数据结构是 FIFO 先进先出双向链表 Node：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static final class Node { /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor\u0026#39;s thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; } 两种场景 尝试获取锁（修改标记位，立即返回） 1 2 3 protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } AQS 继承类必须重写这个方法，给上层提供操作空间\n获取锁（修改标记位），愿意进入队列等待，直到获取 1 2 3 4 5 public final void acquire(int arg) { if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 不允许修改 final\n调用 tryAcquire() ，失败直接跳出\naddWaiter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } 将当前线程封装成一个 Node 对象\nacquireQueued：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 这里的 if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) 会判断当前节点是否有资格获取锁，没资格的挂起，避免没必要的自旋\nTips Java 中断 作用于线程对象，并不会直接促成该线程挂起，会根据当前状态产生不同效果 如果当前线程是运行状态，那么改线程的运行并不会被影响 如果当前线程是等待状态，那么对该线程 interrupt 使其抛出中断异常 判断方法 shouldParkAfterFailedAcquire 如果前置节点正在等待拿锁，那么当前节点自然可以挂起休息，返回 true 如果前置节点状态 \u0026gt; 0 ，那么只会是 CANCELLED，直接从队列里删除 如果前置节点是其他状态，那么既然当前节点已经加入，那么前置节点状态设置为 SINGLE，让其被唤醒，返回 false 当 shouldParkAfterFailedAcquire 返回 true 执行真正的挂起操作\n1 2 3 4 private final boolean parkAndCheckInterrupt() { LockSupport.park(this); // 在这里挂起 return Thread.interrupted(); } 唤醒时机 1 2 3 4 5 6 7 8 9 10 11 12 13 protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); } public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } unparkSuccessor：此方法是为了唤醒 Head 后面的 Node，使其自旋地获取锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws \u0026lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus \u0026gt; 0) { s = null; for (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev) if (t.waitStatus \u0026lt;= 0) s = t; } if (s != null) LockSupport.unpark(s.thread); } 从尾节点开始找，找到 Head 后最靠前的 ws 小于等于 0 的节点，并唤醒对应的线程\n一旦线程被唤醒，他就会继续调用 acquireQueued 方法进行自旋尝试获取锁\nAQS 相关的组件、工具 ReentrantLock ReentrantLock 基于 AQS，\n在并发编程中可以实现公平锁和非公平锁来对共享资源进行同步\n同时，和 synchronized 一样，ReentrantLock 支持可重入\n除此之外，ReentrantLock 在调度上更灵活，支持更多丰富的内容\nLock 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition(); } 源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ReentrantLock implements Lock, java.io.Serializable { private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer {...} // Sync object for non-fair locks static final class NonfairSync extends Sync {...} // Sync object for fair locks static final class FairSync extends Sync {...} Sync： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); final boolean nonfairTryAcquire(int acquires) {...} protected final boolean tryRelease(int releases) {...} protected final boolean isHeldExclusively() {...} final ConditionObject newCondition() {...} // Methods relayed from outer class final Thread getOwner() {...} final int getHoldCount() {...} final boolean isLocked() {...} private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {...} } 继承自 AQS ，可以使用 AQS 的特性\n被 abstract 修饰，需要子类来实例化\nJava 核心类库及其底层原理 JDK，JRE，JVM之间的区别 JDK JDK 是 JAVA 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常见的 Java 类库等\nJRE JRE 是 Java 运行环境，用于运行 Java 的字节码文件。JRE 中包括了 JVM 以及 JVM 工作所需的类库，普通用户只需要安装 JRE 来运行 Java 程序，而程序开发者必须安装 JDK 来编译、调试程序\nJVM JVM 是 Java 虚拟机，是 JRE 的一部分，是整个 Java 实现跨平台最核心的部分，负责运行字节码文件\ne.g. 写 Java 代码，txt 就可以写，但是写出来的代码，想要运行，需要编译成字节码，需要编译器，JDK 中包含编译器 javac，编译折后的字节码想要运行，需要一个可执行字节码的程序，这个程序就是 JVM，专门用来执行 Java 字节码的\n开发需要 JDK\n运行编译好的 Java 字节码文件需要 JRE\nJVM 在执行 Java 字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令有可能是不一样的，导致不同操作系统的 JVM 是不一样的，所以安装 JDK 时要选择操作系统\n另外 JVM 执行的是 Java 字节码，所以只要编译后是 Java 字节码，都可以在 JVM 上运行，比如 Apache Groovy，Scala ， Kotlin 等\nJVM 中，哪些时线程共享区 项目如何排查 JVM 问题 对于还在正常运行的系统 可以使用 jmap 来查看 JVM 中各个区域的使用情况 可以使用 jstack 来查看线程运行情况，比如哪些线程阻塞、是否出现死锁 可以用 jstack 命令来查看垃圾回收的情况，特别是 fullgc，如果发现 fullgc 比较频繁，那么就得进行调优 通过各个命令的结果或 jvisualvm 等工具来进行分析 首先，初步猜测频繁 fullgc 的原因，如过频繁发生 fuulgc 又没有 OOM，那么表示 fuulgc 实际上是回收了很多对象了，所以这些对象最好能在 younggc 过程中就直接回收掉，避免这些对象进入老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入老年代，尝试加大年轻代的大学，如果改完后，fullgc 减少，那么修改有效 同时，还可以找到占用 CPU 最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存 对于已经发生 OOM 的系统 一般生产系统中都会设置当系统发生 OOM 时，生成当时的 dump 文件 可以利用 jsisualvm 等工具来分析 dump 文件 根据 dump 文件找到异常的实例对象，和异常的线程（占用 CPU 高），定位到具体的代码 然后进行详细的分析和调试 总结 调优不是一蹴而就的，需要分析、推理、实践、总结、再分析\nhashCode() 与 equals() 之间的关系 理论 在 Java 中，每个对象都可以调用自己的 hashCode() 方法得到自己的哈希值，相当于对象的指纹信息，通常来说不会有相同的，但 Java 中做不到这样绝对，但我们仍然可以使用 hashCode 来做一些判断\n如果两个对象的 hashCode 不同，这两个对象一定同 如果两个对象的 hashCode 相同，不代表一定是同一个对象 如果两个对象相等，那么 hashCode 一定相同 在 Java 的一些集合类的实现中，在比较两个对象是否相等时，会根据上面的原则，先调用 hashCode() 方法进行比较，如果不同直接判定不同，如果相同进一步调用 equals() 方法。equals() 方法就是来最终确定两个对象是不是相等的。equals() 的实现通常会很重，逻辑较多。\n所以 在我们重写了 equals() 方法时，一定要确保 hashCode() 方法能遵循上述规则\ndemo 演示 未重写 hashCode()\nUser 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 package JAVA.hash_and_equals; import java.util.HashMap; public class TestHashEquals { public static void main(String[] args) { HashMap\u0026lt;User, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(new User(\u0026#34;AKAxedx\u0026#34;), \u0026#34;111\u0026#34;); System.out.println(hashMap.get(new User(\u0026#34;AKAxedx\u0026#34;))); } } 运行结果：null\n原因：hashMap 中的 get 方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param key the key * @return the node, or null if none */ final Node\u0026lt;K,V\u0026gt; getNode(Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n, hash; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; (hash = hash(key))]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { //这里调用了 hash 进行对比 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))// 短路掉了 equals() 方法 return e; } while ((e = e.next) != null); } } return null; } 重写 User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } @Override public int hashCode() { return name.hashCode(); } } 运行结果：111\n== 和 equals 方法的区别 == 如果比较基本数据类型，比较的是值，如果是引用类型，比较的是引用地址 equals() 使用 equals() 方法比较，具体逻辑看具体实现，比如String 类型，虽然是引用类型，但是 String 重写了 equals() 方法，比较的是字符串中各个字符是否相等 String、StringBuffer、StringBuilder的区别 String 是不可变的，如果尝试修改，会生成一个字符串对象，StringBuffer 和 StringBuilder 是可变的 StringBuffer 是线程安全的，StringBuilder 是线程不安全的，单线程环境下 StringBuilder 效率更高 泛型中 extends 和 super 的区别 \u003c? extends T\u003e 表示包括 T 在内的任何 T 的子类 \u003c? super T\u003e 表示包括 T 在内的任何 T 的父类 重载和重写的区别 重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时\n重写 发生在父子类中，方法名，参数列表必须相同，返回值返回小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 private 则不能重写该方法\nList 和 Set 的区别 List 有序，按对象进入的顺序保存对象，可重复，允许多个 Null 元素对象，可以使用 Iterator 取出所有元素，再逐一遍历，还可以使用 get 获取指定下标的元素\nSet 无序，不可重复，最多允许一个 Null 元素对象，取元素时只能使用 Iterator 接口取得所有元素，再逐一遍历\nArrayList 和 LinkedList 的区别 底层数据结构不同，ArrayList 基于数组，而LinkedList 基于链表\n由于底层数据结构不同，他们使用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加。查询、添加、删除的时间复杂度不同\n都是先了 List 接口，而 LinkedList 还而额外实现了 Deque 接口，所以 LinkedList 还能当队列来使用\nConcurrentHashMap 的扩容机制 JDK 1.7版本 ConcurrentHashMap 是基于 Segment 分段实现的 每个 Segment 相当于一个小的 HashMap 每个 Segment 内部会进行扩容，和 HashMap 扩容类似 先生成新的数组，然后转移元素到新数组中 扩容的判断也是每个 Segment 内部单独判断的，判断是否超过阈值 JDK 1.8版本 不再使用 Segment 实现 当某个线程进行 put 时，如果 ConcurrentHashMap 正在扩容，那么该线程一起进行扩容 如果某个线程 put 时，没有在进行扩容，则将 key-value 添加到 ConcurrentHashMap 中，然后判断是否超过阈值，超过进行扩容 ConcurrentHashMap 支持多线程同时扩容 扩容之前生成一个新的数组 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作 JDK1.7-JDK1.8 HashMap 发生了什么变化 JDK1.7 数组 + 链表\n头插法\nhash 算法复杂\nJDK1.8 数组 + 链表 + 红黑树\n红黑树提高插入和查询的整体效率\n尾插法\nhash 算法简化\nHashMap 的 put 方法 大致如下\n通过哈希算法与与运算计算得出数组下标 如果数组下标为空，则将 key-value 封装为 Entry (1.8 版本为 Node) 对象，并放入该位置 如果是 JDK1.7，先判断是否扩容，如果扩容，就进行扩容，不扩容就生成 Entry 对象，使用头插法插入当前位置的链表中 如果是 JDK1.8，先判断该位置上的 Node 的类型（链表、红黑树） 如果是红黑树 Node，将 key-value 封装成一个 红黑树节点并添加进树中（插入/更新） 如果是链表 Node，则将 key-value 封装为一个链表 Node 并通过尾插法插入当前链表尾部，由于尾插进行了遍历，遍历过程中进行插入或更新，如果长度大于 8，将链表转换成红黑树 插入链表或红黑树后才进行判单是否进行扩容 HashMap 的扩容机制 JDK1.7 先生成新数组 遍历老数组的每个位置上的链表的每个元素 取出每个元素的 key，并基于新的数组长度，计算出每个元素再新数组中的下标 将元素添加到新数组中去 所有元素转移完后，将新数组赋值给 HashMap 对象中的 table 属性 JDK1.8 先生成新数组 遍历老数组中的每个位置的链表或红黑树 如果是链表，则直接将链表中的每个元素重新计算下标，添加到新数组中 如果是红黑树，先遍历红黑树，计算每个元素对应的下标位置 统计每个下标位置的元素个数 如果该位置的元素超过了8，生成一个新的红黑树，并将根节点的添加到新数组的对应位置 如果没有超过8，则生成一个链表，将头节点添加到数组的对应位置 所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性 深拷贝和浅拷贝 深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用\n浅拷贝是指，只拷贝基本数据类型的值，以及实例对象的引用地址，不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的属性指向的是同一个对象 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象 CopyOnWriteArrayList 的底层原理 首先 CopyOnWriteArrayList 内部也是数组，在向 CopyOnWriteArrayList 添加元素时，会赋值一个新的数组，写操作在新数组上进行，读操作在原数组上进行 写操作加锁，防止出现并发写入丢失数据的问题 写操作结束之后会把原数组指向新数组 CopyOnWriteArrayList 允许在写操作时来读数据，提高了读的性能，适合多读少写的应用场景，但是 CopyOnWriteArrayList 比较占内存，同时可能读到的数据不是最新的，不适合实时性要求很高的场景 什么是字节码，采用字节码的好处 编译器将 Java 源文件编译成字节码文件，可以做到一次编译到处允许，win 上编译好的 class 文件，可以直接在 linux 上允许，通过这种方式做到跨平台，前提是，不同的操作系统上安装的 JDK 或 JRE 是不同的，虽然字节码通用，但把字节码解释成各个操作系统机器码是需要不同的解释器的，所以各个操作系统需要自己的 JDK 和 JRE\n采用自己尔玛的好处，一方面实现了跨平台，一方面提高了代码执行的性能，编译器在编译源代码时可以做一些编译器的优化，比如锁消除、标量替换、方法内联等\nJava 异常体系 Java 中所有异常都来自顶级父类 Throwable Throwable 下有两个子类 Exception 和 Error Error 表示非常严重的错误，比如 java.lang.StackOverFlowError 和 OOM ，通常这些错误出现时，仅靠程序自己时解决不了的，可能时虚拟机、磁盘、操作系统层面出现了问题，所有通常不建议在代码中去捕获这些 Error，因为捕获的意义不大，因为程序可能已经运行不了了 Exception 表示异常，表示程序出现 Exception 时，是可以靠自己来解决的，比如空指针，数组越界等，我们可以捕获这些异常来进行特殊处理 Exception 的子类通常可分为 RuntimeException 和非 RuntimeException 异常 RuntimeException 表示运行期异常，表示这个异常实在代码运行过程中抛出的，这些事非检查异常，程序中可以选择捕获或直接抛出，这些异常一般是由逻辑错误引起的，程序应该从逻辑角度尽可能避免，比如空指针和数组越界 非 RuntimeException 表示非运行期异常，也即是检查异常，是必须进行处理的异常，如果不处理，程序就不能检查异常通过，如 IOException，SQLException 等以及用户自定义的 Exception 异常 什么时候抛出异常，什么时候捕获异常 异常是一种提示，抛出异常相当于告诉上层方法，我抛出了一个异常，我处理不了，交给你处理。而上层方法他也需要判断能否处理这个异常\n所有在写方法时，要考虑本方法能否合理地处理该异常，处理的了捕获，处理不了抛出\nJava 中有哪些类加载器 BootstrapClassLoader：是ExtClassLoader 的父类加载器，赋值加载 %JAVA_HOME%/lib 下的 jar 包和 class 文件 ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载 %JAVA_HOME%/lib/ext 文件夹下的 jar 包和 class 类 AppClassLoader 是自定义类加载器的父类，负责加载 classpath 下的类文件 类加载器双亲委派模型 JVM 中存在三个默认的类加载器\nBootstrapClassLoader ExtClassLoader AppClassLoader JVM 在加载一个类时，会调用 AppClassLoader 的 loadClass 方法来加载这个类，不管在这个方法中，会先使用 ExtClassLoader 的 loadClass 方法来加载类，同样 ExtClassLoader 的 loaderClass 会使用 BootstrapClass 的 loaderClass 方法来加载类，如果 BootstrapClassLoader 加载到了直接成功，如果没有则 ExtClassLoader 加载，如果还没有则 AppClassLoader 加载\n所以，双亲委派指的是，JVM 在加载类时，会委派给父类加载，没加载到才自己进行加载\n一个对象加载到 JVM，再到被 GC 清除，都经历了什么过程 首先把字节码文件内容加载到方法区 根据类信息再堆区创建对象 对象首先会分配再堆区中年轻代的 Eden 区，经过一次 Minor GC 后，如果对象存活，进入 Suvivor 区，在后续的每次 Minor GC中，如果对象一直存活，就会在 Suvivor 区来回拷贝，没移动一次，年龄加1 当年龄超过15后，对象依然存活，对象进入老年代 如果经过 Full GC，被标记为垃圾对象，那么就会被 GC 线程清理掉 怎么确定一个对象到底是不是垃圾 引用计数法：这种方式时给堆内存当中每个对象记录一个引用个数，引用个数为0的就认为是垃圾，这是早期 JDK 中使用的方法，引用计数无法解决循环引用的问题 可达性算法：这种方法是再内存中，从根对象一直向下找引用，找到的对象就不是垃圾，没找的是垃圾 JVM 有哪些垃圾回收算法 标记清除算法： 标记阶段：把垃圾内存标记出来 清除阶段：直接将垃圾内存回收 赭红算法简单，但会产生大量内存碎片 复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法，复制算法将内存分为大小相等的两半，每次只是用其中一半，垃圾回收时，将当前这一块的内存活对象全部拷贝到另一半，然后这一半直接清除，这种算法没有内存碎片，但是浪费空间 标记压缩法：为了解决复制算法的缺陷，提出标记压缩法，这张算法在标记阶段和清除算法一样，标记完后，不直接清除垃圾，而是将存活对象往一端移动，然后将边界外的所有内存清除 什么是 STW Stop-The-World，实在垃圾回收算法执行过程当中，需要将 JVM 内存冻结的一种状态，在 STW 状态下，Java 所有线程都是停止执行的-GC线程除外，native 方法可以执行，但是，不能与 JVM 交互，GC 各种算法优化的重点，就是减少 STW，这也是 JVM 调优的重点\nJVM 参数有哪些 绝大数情况下，常用的有十来个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # JVM 启动参数不换行 # 设置堆内存 -Xmx4g -Xms4g # 指定 GC 算法 -XX:+UseG1GC -XX:MaxGCPauseMillis=50 # 指定 GC 并行线程数 -XX:ParallelGCThreads=4 # 打印 GC 日志 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 指定 GC 日志文件 -Xloggc:gc.log # 指定 Meta 区的最大值 -XX:MaxMetaspaceSize=2g # 设置单个线程栈的大小 -Xss1m # 指定堆内存溢出时自动进行 Dump -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ","date":"2024-08-25T05:53:40+08:00","image":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/698503_hu14773505816458707756.jpg","permalink":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/","title":"Java 基础"},{"content":"Spring 基础 回顾 bean 的注入方式 xml 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.example.demo.demos.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;张三\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 注解 1 2 @Controller public class UserController {} 1 2 3 @Service @DependsOn(value = {\u0026#34;xxx\u0026#34;,\u0026#34;yyyy\u0026#34;}) public class UserDao {} 1 2 @Repository public class UserDao {} 1 2 3 @Compoment @DependsOn(value = {\u0026#34;xxx\u0026#34;,\u0026#34;yyyy\u0026#34;}) public class RedisTemplate{} 配置类 1 2 3 4 5 6 7 8 9 10 @Configuration public class UserConfiguration { @Bean(\u0026#34;user\u0026#34;) public User user(){ User user = new User(); user.setName(\u0026#34;张三\u0026#34;); user.setAge(18); return user; } } import 注解 1 2 3 4 5 6 7 8 9 10 11 12 public class MySelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[] { \u0026#34;com.exampl.demo.demos.User\u0026#34;,\u0026#34;...\u0026#34; }; } } @Configuration @Import(MySelector.class) public class UserConfiguration{} 我们由各种各样的方式将一个 Bean 注入容器，怎么做到的\nBeanDefinition 详解 Spring 在构造 Bean 时，不可能像我们主动构造那样，随心所欲进行 new、赋值、调用方法。他需要将千差万别的 class 概括成为一种【统一的描述性】语言， Spring 提供了一个接口 BeanDefinition 为我们统一了这种描述性的元数据\nbean 的元数据通常是我们使用 xml 或者注解进行配置的数据，我们的 Spring 容器启动之间第一步就是加载配置数据，这些元数据会被加载到内存以一个个 BeanDefinition 的形式保存在一个 map 中\n我们猜想一个 BeanDefinition 的具体实现大概保存了以下信息，我们可以很容易查看这个接口：\nid、别名 具体的工厂方法（Class 类型），包括工厂方法的返回类型，工厂方法的 Method 对象 构造函数形参列表，类的属性列表 Bean 的 class 对象 ","date":"2024-08-25T02:25:02+08:00","image":"https://akaxedx.github.io/zoye.png","permalink":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","title":"Spring 源码解析笔记"}]