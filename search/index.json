[{"content":"Tomcat 中为什么要使用自定义类加载器 一个 Tomcat 中可以部署很多个应用，而每个应用中都存在很多类，各个应用中的类是独立的，全类名是可以相同的。一个 Tomcat 不管内部部署了多少应用，Tomcat 启动之后就是一个 Java 进程，也就是一个 JVM，所以如果 Tomcat 中只存在一个类加载器，比如默认的 AppClassLoader，那么只能加载一个同名类，这是有问题的。在 Tomcat中，会为部署的每个应用都生成一个类加载器实例，叫做 WebAppClassLoader，这样 Tomcat 中每个应用都可以使用自己的类加载器去加载自己的类，实现应用之间的类隔离，不出现冲突。另外 Tomcat 还利用自定义加载器实现了热加载的功能\n","date":"2024-08-25T18:10:13+08:00","image":"https://akaxedx.github.io/p/tomcat/saber_hu18427175924411022449.jpg","permalink":"https://akaxedx.github.io/p/tomcat/","title":"Tomcat"},{"content":"JUC Java 中创建线程的方式 继承Thread类 1 2 3 4 5 6 7 8 9 10 11 public class TestThread extends Thread{ public static void main(String[] args) { TestThread thread = new TestThread(); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 由于 Java 是单继承，直接继承 Thread 会限制继承其他类，因此多用 Runnable 接口实现多线程 Thread 也是继承了 Runnable 接口的类，本质上还是等于继承了 Runnable 接口 实现Runnable接口 1 2 3 4 5 6 7 8 9 10 11 public class TestRunnable implements Runnable{ public static void main(String[] args) { Thread thread = new Thread(new TestRunnable()); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 匿名内部类实现多线程\n1 2 3 4 5 6 7 8 9 10 11 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } }); thread.start(); } } 使用 lambda 表达式简化\n1 2 3 4 5 6 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(() -\u0026gt; System.out.println(\u0026#34;111\u0026#34;)); thread.start(); } } 实现 Callable 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestCallable implements Callable\u0026lt;String\u0026gt; { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(new TestCallable()); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); System.out.println(result); } @Override public String call(){ return \u0026#34;111\u0026#34;; } } 与 Runnable 的区别在于可以拿到线程执行的结果，这里需要与 FutureTask 结合使用 而 FutureTask 是继承的 Runnable 接口和 Future 接口的接口 线程池创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestThreadPool implements Runnable{ public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new TestThreadPool()); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 总结 以上四种方式底层均为 Runnable 接口\n不建议使用 Executors 创建线程池的原因 FixedThreadPool 当我们使用 Executors 创建 FixedThreadPool 时，对应的构造方法为\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 这里 LinkedBlockingQueue 是一个无界的阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加进队列，会有 OOM 的风险 SingleThreadExecutor 当我们使用 Executors 创建 SingleThreadExecutor 时，对应的构造方法为\n1 2 3 4 5 6 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } 也是 LinkedBlockingQueue 总结 除了 OOM 的风险外，我们使用 Executors 来创建线程池也不能自定义线程的名字，不利于排查问题，所以应该用 ThreadPoolExecutor 直接定义线程池，可以灵活控制\n线程池有哪几种状态，每种状态分别表示什么 RUNNING 表示线程池正常运行，既能接收新任务，也会正常处理队列中的任务\nSHUTDOWN 当调用线程池 shutdown() 方法时，进入 SHUTDOWN 状态，表示线程池正处于关闭状态，不会接收新任务，但会继续把队列中的任务处理完\nSTOP 当调用线程池 shutdownnow() 方法时，线程池进入 STOP 状态，表示线程池正处于停止状态，此状态 不会接收新任务，也不会处理队列中的任务，正在运行的线程也会终断\nTIDYING 线程池中没有线程运行后，线程池状态自动变为 TIDYING，并且调用 terminated()，该方法是空方法，可以自行扩展\nTERMINATED terminated() 方法执行完后，线程池状态变为 TERMINATED\nSynchronized 和 ReentrantLock Synchronized ReentrantLock Java 中的一个关键值 JDK 提供的一个类 自动加锁与释放锁 手动加锁与释放 JVM 层面的锁 API 层面的锁 非公平锁 公平锁或非公平锁 锁的是对象，锁信息保存在对象头中 int 类型的 state 标识来标识锁的状态 底层有锁升级的过程 没有锁升级的过程 ReentrantLock分为公平和非公平锁，底层是怎么实现的 首先，不管是公平锁还是非公平锁，他们的底层实现都会用 AQS 来进行排队，他们的区别在于线程在使用 lock() 方法加锁时：\n公平锁：检查 AQS 队列中是否存在线程在排队，如果有，则当前线程也进行排队 非公平锁：不检查是否排队，直接竞争锁 总结 不管是否是公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁知识体现在的线程加锁阶段，而没有体现在线程被唤醒阶段\nReentrantLock 是可重入锁，不管是否公平\nSynchronized 锁是怎么升级的 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程 ID，该线程下次如果又来获取该锁就可以直接获取到了，也就是支持锁重入 轻量级锁：有偏向锁升级，当一个线程获取到锁后，此时这把锁是偏向锁，此时又有第二个线程来竞争锁，偏向锁会升级为轻量级锁，轻量级锁通过自旋实现，不会阻塞线程 自旋次数过多仍没有获取到锁，则会升级成重量级锁，重量级锁会导致线程阻塞 自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较耗费时间，自旋锁是线程通过 CAS 获取预期的一个标记，如果没获取到则循环获取，这个过程线程一直在运行中，没有使用太多操作系统资源，比较轻量 ThreadLocal的应用场景，底层实现是什么样的 ThreadLocal 底层 ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利用该机制将数据 缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据 ThreadLocal 底层是通过 ThreadLocalMap 实现的，每个 Thread 对象中都存在一个 ThreadLocalMap，Map 的 key 为 Threadlocal 对象，Map 的 value 为需要缓存的值 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestThreadLocal { private ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public void a() { local.set(\u0026#34;111\u0026#34;); b(); } public void b() { String s = local.get(); System.out.println(s); } } 在线程池中使用 ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使用完后，应该把设置的 key，value 也就是 Entry 对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap，ThreadLocalMap 也是通过强引用指向 Entry 对象，线程不被回收，Entry 对象也就不会回收，从而出现内存泄漏。解决方法是，在使用 ThreadLocal 对象后，手动调用 ThreadLocal d remove 方法，手动清除 Entry 对象 应用场景 一个经典的场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接）\nJava 核心类库及其底层原理 JDK，JRE，JVM之间的区别 JDK JDK 是 JAVA 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常见的 Java 类库等\nJRE JRE 是 Java 运行环境，用于运行 Java 的字节码文件。JRE 中包括了 JVM 以及 JVM 工作所需的类库，普通用户只需要安装 JRE 来运行 Java 程序，而程序开发者必须安装 JDK 来编译、调试程序\nJVM JAVM 是 Java 虚拟机，是 JRE 的一部分，是整个 Java 实现跨平台最核心的部分，负责运行字节码文件\ne.g. 写 Java 代码，txt 就可以写，但是写出来的代码，想要运行，需要编译成字节码，需要编译器，JDK 中包含编译器 javac，编译折后的字节码想要运行，需要一个可执行字节码的程序，这个程序就是 JVM，专门用来执行 Java 字节码的\n开发需要 JDK\n运行编译好的 Java 字节码文件需要 JRE\nJVM 在执行 Java 字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令有可能是不一样的，导致不同操作系统的 JVM 是不一样的，所以安装 JDK 时要选择操作系统\n另外 JVM 执行的是 Java 字节码，所以只要编译后是 Java 字节码，都可以在 JVM 上运行，比如 Apache Groovy，Scala ， Kotlin 等\nhashCode() 与 equals() 之间的关系 理论 在 Java 中，每个对象都可以调用自己的 hashCode() 方法得到自己的哈希值，相当于对象的指纹信息，通常来说不会有相同的，但 Java 中做不到这样绝对，但我们仍然可以使用 hashCode 来做一些判断\n如果两个对象的 hashCode 不同，这两个对象一定同 如果两个对象的 hashCode 相同，不代表一定是同一个对象 如果两个对象相等，那么 hashCode 一定相同 在 Java 的一些集合类的实现中，在比较两个对象是否相等时，会根据上面的原则，先调用 hashCode() 方法进行比较，如果不同直接判定不同，如果相同进一步调用 equals() 方法。equals() 方法就是来最终确定两个对象是不是相等的。equals() 的实现通常会很重，逻辑较多。\n所以 在我们重写了 equals() 方法时，一定要确保 hashCode() 方法能遵循上述规则\ndemo 演示 未重写 hashCode()\nUser 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 package JAVA.hash_and_equals; import java.util.HashMap; public class TestHashEquals { public static void main(String[] args) { HashMap\u0026lt;User, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(new User(\u0026#34;AKAxedx\u0026#34;), \u0026#34;111\u0026#34;); System.out.println(hashMap.get(new User(\u0026#34;AKAxedx\u0026#34;))); } } 运行结果：null\n原因：hashMap 中的 get 方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param key the key * @return the node, or null if none */ final Node\u0026lt;K,V\u0026gt; getNode(Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n, hash; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; (hash = hash(key))]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { //这里调用了 hash 进行对比 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))// 短路掉了 equals() 方法 return e; } while ((e = e.next) != null); } } return null; } 重写 User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } @Override public int hashCode() { return name.hashCode(); } } 运行结果：111\n","date":"2024-08-25T05:53:40+08:00","image":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/698503_hu14773505816458707756.jpg","permalink":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/","title":"Java 基础"},{"content":"JAVA 基础 包含 Java SE、JUC 等 Java 语言相关的特性\n具体地址\n","date":"2024-08-25T05:44:46+08:00","image":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B_hu13581451615509590227.PNG","permalink":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/","title":"备战秋招"},{"content":"\n","date":"2024-08-25T02:25:02+08:00","image":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/image-20240825022846591_hu11050290388165439678.png","permalink":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","title":"Spring 源码解析笔记"}]