[{"content":"Spring 谈谈 IOC IOC - 控制反转\n什么是控制，控制了什么 我们在使用 Spring 时，会建一些类，比如 UserService\n使用一些注解，比如 @Autowired\n但是，当程序运行时，用的是具体的 UserService 对象，那么这些对象是什么时候创建的，谁创建的，对象里的值哪里来的，这些都是 Spring 做的\n这就是控制\n控制对象的创建 控制对象内属性的赋值 什么是反转 如果我们不使用 Spring，就需要我们自己创建对象以及赋值，反过来，Spring 帮我们做这些，这就是 反转，表示一种 对象控制权 的转移\n反转有什么用，为什么反转 如果我们自己负责创建对象，自己赋值，会出现什么情况\n比如现在有三个类\nA 类，A 类里有一个属性 C c B 类，B 类里也有一个属性 C c C 类 现在程序要运行，这三个类的对象都要创建出来，并且相应的属性要有值，那么除开定义这三个类，我们还需要写\nA a = new A() B b = new B() C c = new C() a.c = c b.c =c 我们会多些很多业务代码，而且随着属性变多，类变多，代码会变得异常复杂，将这些工作交给 Spring，减轻了程序员的负担\n总结 IoC 表示控制反转，表示如果使用 Spring，那么 Spring 会负责来创建对象，以及给对象内的属性赋值，也就是如果用 Spring，那么对象的控制权将转交给 Spring\n单例 Bean 和单例模式 单例模式表示 JVM 中某个类的对象只会存在一个\n单例 Bean 并不表示 JVM 中只能存在唯一的某个类的对象\n单例 Bean ，使用同一个名字能拿到同一个对象，但我可以 new 出来很多个该对象取不同的名字\nSpring 事务传播机制 多个事务方法相互调用时，事务如何在这些方法间传播，方法 A是一个事务的方法，方法 A 执行过程中调用了方法 B，那么方法 B 有无事务以及方法 B 对事务的要求不同都会对方法 A 的事务具体执行造成影响，同时方法 A 的事务对方法 B 的事务执行也有影响，这种影响具体是什么就由这两个方法所定义的事务传播类型所决定\nREQUIRED（Spring 默认的事务传播类型）：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务 SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行 MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常 REQUIRED_NEW：创建一个新事物，如果当前存在事务，则挂起该事务 NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务 NEVER：不使用事务，如果当前事务存在，则抛出异常 NESTED：如果当前事务存在，则在嵌套事务中执行，否则开启一个事物 Spring ","date":"2024-08-30T17:59:49+08:00","image":"https://akaxedx.github.io/p/spring/saber_hu3822888719987798397.jpg","permalink":"https://akaxedx.github.io/p/spring/","title":"Spring"},{"content":"计网基础 描述下 HTTP 和 HTTPS 的区别 HTTP：互联网上应用最为广泛的一种网络通信协议，基于 TCP，可以使浏览器工作更为高效，减少网络传输 HTTPS：是 HTTP 的加强版，可认为是 HTTP + SSL（Secure Socket Layer）。在 HTTP 的基础上增加了一系列的安全机制。一方面保证数据传输安全，另一方面对网文者增加了验证机制。是目前现行架构下，最为安全的解决方案 主要区别 HTTP 的连接是简单无状态的，HTTPS 的数据传输是经过证书加密的，安全性更高 HTTP 是免费的，HTTPS 需要申请证书，证书通常需要收费，费用一般不低 他们的传输协议不同，所使用的端口也不同，HTTP 默认80端口，HTTPS 默认是 443 HTTPS 的缺点\nHTTPS 的握手协议比较费时，所以会影响服务的相应速度以及吞吐量 HTTPS 也并不是完全安全的。他的证书体系起始并不完全安全，HTTPS 在面对 DDOS 的攻击时，几乎起不到任何作用 功能越强大的证书费用越高 Cookie 和 Session 的区别 当服务器 tomcat 第一次接收到客户端请求时，会开辟一块独立的 session 空间，建立一个 session 对象，同时会生成一个 session id，通过响应头的方式保存到客户端浏览器的 cookie 当中。以后客户端每次请求，都会在请求头部带上这个 session id，这样可以对应上服务端的一些会话的相关信息，比如用户的登录状态\n如果没有客户端的 Cookie，Session 是无法进行身份验证的\n当服务端从单体应用升级为分布式之后，cookie + session 这种机制要怎么扩展\nsession 黏贴：在负载均衡中，通过一个机制保证所有的请求都会转发到同一个 tomcat 实例中。问题：当这个 tomcat 实例出现问题后，请求会被转发到其他实例，这时候用户的 session 信息丢失 session 复制：当一个 tomcat 实例上保存了 session 信息后，主动将 session 复制到集群中的其他实例。问题：复制需要时间，在复制过程中，容易产生 session 信息丢失 session 共享：将服务端的 session 信息保存到一个第三方中，比如 redis。可实现单点登录 BIO，NIO，AIO 分别是什么 BIO：同步阻塞 IO，使用 BIO 读取数据，线程会阻塞住，并且需要线程主动去查询是否有数据可读，并且需要处理完一个 Socket 之后才能处理下一个 Socket NIO：同步非阻塞 IO，使用 NIO 读取数据时，线程不会阻塞，但需要线程主动去查询是否有 IO 事件 AIO：也叫 NIO2.0，异步非阻塞 IO，使用 AIO 读取数据时，线程不会阻塞，并且当有数据可读时会通知给线程，不需要线程主动去查询 Netty 的高性能体现在哪些方面 NIO 模型，用最少的资源做更多的事情 内存零拷贝，尽量减少不必要的内存拷贝，实现了更高效率的传输 内存池设计，申请的内存可以重用，主要指直接内存，内部实现使用一颗二叉查找树管理内存分配情况 串行化处理读写：避免使用锁带来的性能开销。即消息的处理尽可能在同一个线程内完成，期间不进行线程切换。这样避免了多线程竞争和同步锁。表面上看，串行化设计似乎 CPU 利用率不高，但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列+对各工作线程模型性能更优 高性能序列化协议：支持 protobuf 等高性能序列化协议 高效并发编程的体现：volatile 的大量、正确使用。CAS 和原子类的管饭使用，线程安全容器的使用，通过读写锁提升开发性能 ","date":"2024-08-29T20:13:09+08:00","image":"https://akaxedx.github.io/p/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/saber_hu3120267142170166617.jpg","permalink":"https://akaxedx.github.io/p/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/","title":"计网基础"},{"content":"Tomcat Tomcat 中为什么要使用自定义类加载器 一个 Tomcat 中可以部署很多个应用，而每个应用中都存在很多类，各个应用中的类是独立的，全类名是可以相同的。一个 Tomcat 不管内部部署了多少应用，Tomcat 启动之后就是一个 Java 进程，也就是一个 JVM，所以如果 Tomcat 中只存在一个类加载器，比如默认的 AppClassLoader，那么只能加载一个同名类，这是有问题的。在 Tomcat中，会为部署的每个应用都生成一个类加载器实例，叫做 WebAppClassLoader，这样 Tomcat 中每个应用都可以使用自己的类加载器去加载自己的类，实现应用之间的类隔离，不出现冲突。另外 Tomcat 还利用自定义加载器实现了热加载的功能\n","date":"2024-08-25T18:10:13+08:00","image":"https://akaxedx.github.io/p/tomcat/saber_hu18427175924411022449.jpg","permalink":"https://akaxedx.github.io/p/tomcat/","title":"Tomcat"},{"content":"Java 基础 JUC 对线程安全的理解 线程安全指的是，我们写的某段代码，在多个线程同时执行时，不会产生混乱，依然能够得到正常的结果，比如 i++，初始化为0，那么两个线程来同时执行这行代码，如果代码时线程安全的，那么最终结果应该就是一个线程的结果为1，一个线程结果为2，如果出现了两个线程结果都为1，则表示这段代码线程不安全\n对守护线程的理解 线程分为用户线程和守护线程，用户线程就是普通线程，守护线程时 JVM 的后台线程，比如垃圾回收线程就是一个守护线程，守护线程会在其他普通线程都停止运行后自动关闭，我们可以通过设置 thread.setDaemon(true) 来把一个线程设置为守护线程\n并发、并行、串行之间的区别 串行：一个任务执行完，才能执行下一个 并行：两个任务同时执行 并发：两个任务看上去是同时执行的，但实际上是任务被分成了很多分，然后一个一个执行 Java 避免死锁 造成死锁的原因 一个资源每次只能被一个线程使用 一个线程在阻塞等待某个资源时，不释放已占有资源 一个线程已经获得资源，在未使用完之前，不能强行剥夺 若干线程形成头尾相接的循环等待资源关系 这是形成死锁的必须达到的四个条件，只要不满足其中一个，就能避免死锁的形成，而前三个是作为锁的必要条件，所有打破第四个条件，不出现循环等待锁的关系\n开发注意事项 注意加锁顺序，保证每个线程按同样的顺序进行加锁 注意加锁时限，可以针对锁设置超时时间 注意死锁检查，确保在第一时间发现死锁并解决 Java 中创建线程的方式 继承Thread类 1 2 3 4 5 6 7 8 9 10 11 public class TestThread extends Thread{ public static void main(String[] args) { TestThread thread = new TestThread(); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 由于 Java 是单继承，直接继承 Thread 会限制继承其他类，因此多用 Runnable 接口实现多线程 Thread 也是继承了 Runnable 接口的类，本质上还是等于继承了 Runnable 接口 实现Runnable接口 1 2 3 4 5 6 7 8 9 10 11 public class TestRunnable implements Runnable{ public static void main(String[] args) { Thread thread = new Thread(new TestRunnable()); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 匿名内部类实现多线程\n1 2 3 4 5 6 7 8 9 10 11 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } }); thread.start(); } } 使用 lambda 表达式简化\n1 2 3 4 5 6 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(() -\u0026gt; System.out.println(\u0026#34;111\u0026#34;)); thread.start(); } } 实现 Callable 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestCallable implements Callable\u0026lt;String\u0026gt; { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(new TestCallable()); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); System.out.println(result); } @Override public String call(){ return \u0026#34;111\u0026#34;; } } 与 Runnable 的区别在于可以拿到线程执行的结果，这里需要与 FutureTask 结合使用 而 FutureTask 是继承的 Runnable 接口和 Future 接口的接口 线程池创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestThreadPool implements Runnable{ public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new TestThreadPool()); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 总结 以上四种方式底层均为 Runnable 接口\n线程池底层工作原理 线程池内部通过队列+线程实现的，我们利用线程池执行任务时\n如果此时线程池中的线程数量小于 corePoolSize，即线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务 如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue 未满，那么任务被放入缓冲队列 如果此时线程池中的线程数量大于等于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量小于 maximumPoolSize，建新的线程来处理被添加的任务 如果此时线程池中的线程数量大于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量等于 maximumPoolSize，那么通过 handler 所指定的策略来处理此任务 当线程池中的线程数量大于 corePoolSize，如果某线程空闲时间超过 keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数 线程池为什么是先添加队列而不是先创建最大线程 当线程池中的核心线程都在忙时，如果继续往线程池中添加任务，那么任务会先入队列，队列满了之后，才会开新线程。相当于一个公司有十个员工，本来十个员工可以正常处理各种需求，但是随着共公司的发展，需求在慢慢增加，但是一开始这些需求只会增加在待开发列表中，然后这十个员工从待开发列表中获取任务进行处理，但是某一天开发列表满了，十个员工彻底处理不过来了，才会招收新员工\n不建议使用 Executors 创建线程池的原因 FixedThreadPool 当我们使用 Executors 创建 FixedThreadPool 时，对应的构造方法为\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 这里 LinkedBlockingQueue 是一个无界的阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加进队列，会有 OOM 的风险 SingleThreadExecutor 当我们使用 Executors 创建 SingleThreadExecutor 时，对应的构造方法为\n1 2 3 4 5 6 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } 也是 LinkedBlockingQueue 总结 除了 OOM 的风险外，我们使用 Executors 来创建线程池也不能自定义线程的名字，不利于排查问题，所以应该用 ThreadPoolExecutor 直接定义线程池，可以灵活控制\n线程池有哪几种状态，每种状态分别表示什么 RUNNING 表示线程池正常运行，既能接收新任务，也会正常处理队列中的任务\nSHUTDOWN 当调用线程池 shutdown() 方法时，进入 SHUTDOWN 状态，表示线程池正处于关闭状态，不会接收新任务，但会继续把队列中的任务处理完\nSTOP 当调用线程池 shutdownnow() 方法时，线程池进入 STOP 状态，表示线程池正处于停止状态，此状态 不会接收新任务，也不会处理队列中的任务，正在运行的线程也会终断\nTIDYING 线程池中没有线程运行后，线程池状态自动变为 TIDYING，并且调用 terminated()，该方法是空方法，可以自行扩展\nTERMINATED terminated() 方法执行完后，线程池状态变为 TERMINATED\nSynchronized 和 ReentrantLock Synchronized ReentrantLock Java 中的一个关键值 JDK 提供的一个类 自动加锁与释放锁 手动加锁与释放 JVM 层面的锁 API 层面的锁 非公平锁 公平锁或非公平锁 锁的是对象，锁信息保存在对象头中 int 类型的 state 标识来标识锁的状态 底层有锁升级的过程 没有锁升级的过程 ReentrantLock 分为公平和非公平锁，底层是怎么实现的 首先，不管是公平锁还是非公平锁，他们的底层实现都会用 AQS 来进行排队，他们的区别在于线程在使用 lock() 方法加锁时：\n公平锁：检查 AQS 队列中是否存在线程在排队，如果有，则当前线程也进行排队 非公平锁：不检查是否排队，直接竞争锁 总结 不管是否是公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁知识体现在的线程加锁阶段，而没有体现在线程被唤醒阶段\nReentrantLock 是可重入锁，不管是否公平\nReentrantLock 中 tryLock 和 lock 方法的区别 tryLock 表示尝试加锁，可能加到可能加不到。该方法不会阻塞线程，加到返回 true，没有返回 false lock 表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值 CountDownLatch 和 Semaphore 的区别和底层原理 CountDownLatch CountDownLatch 表示计数器，可以给 CountDownLatch 设置一个数字，一个线程调用 CountDownLatch 的 await() 将会阻塞，其他线程可以调用 CountDownLatch 的 countDown() 方法来对 CountDownLatch 中的数字减一，当数字为 0 后，所有 await 的线程将会被唤醒\n原理：待用 await() 方法的线程会利用 AQS 排队，一旦数字被减为0，则会将 AQS 中排队的线程依此唤醒\nSemaphore Semaphore 表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过 acquire() 来获取许可，如果没有许可可用则线程阻塞，并通过 AQS 来排队，可以通过 release() 方法来释放许可，当某个线程释放了某个许可后，会从 AQS 中正在排队的第一个线程一次唤醒，直到没有空闲许可\n谈谈对 AQS 的理解，AQS 如何实现可重入锁 AQS 时一个 Java 线程同步的框架，是 JDK 中很多锁工具的核心实现框架 在 AQS 中，维护了一个信号量 state 和一个线程组成的双向链表队列，其中，这个线程队列，就是用来给线程排队用的，而state 就像是一个红绿灯，用来控制线程排队或者放行的，在不同场景下有不同的意义 在可重入锁这个场景下，state 就用来表示加锁次数，0表示无锁，每加一次锁，state 就加1，释放减1 Synchronized 锁是怎么升级的 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程 ID，该线程下次如果又来获取该锁就可以直接获取到了，也就是支持锁重入 轻量级锁：有偏向锁升级，当一个线程获取到锁后，此时这把锁是偏向锁，此时又有第二个线程来竞争锁，偏向锁会升级为轻量级锁，轻量级锁通过自旋实现，不会阻塞线程 自旋次数过多仍没有获取到锁，则会升级成重量级锁，重量级锁会导致线程阻塞 自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较耗费时间，自旋锁是线程通过 CAS 获取预期的一个标记，如果没获取到则循环获取，这个过程线程一直在运行中，没有使用太多操作系统资源，比较轻量 ThreadLocal的应用场景，底层实现是什么样的 ThreadLocal 底层 ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利用该机制将数据 缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据 ThreadLocal 底层是通过 ThreadLocalMap 实现的，每个 Thread 对象中都存在一个 ThreadLocalMap，Map 的 key 为 Threadlocal 对象，Map 的 value 为需要缓存的值 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestThreadLocal { private ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public void a() { local.set(\u0026#34;111\u0026#34;); b(); } public void b() { String s = local.get(); System.out.println(s); } } 在线程池中使用 ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使用完后，应该把设置的 key，value 也就是 Entry 对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap，ThreadLocalMap 也是通过强引用指向 Entry 对象，线程不被回收，Entry 对象也就不会回收，从而出现内存泄漏。解决方法是，在使用 ThreadLocal 对象后，手动调用 ThreadLocal d remove 方法，手动清除 Entry 对象 应用场景 一个经典的场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接）\nJava 核心类库及其底层原理 JDK，JRE，JVM之间的区别 JDK JDK 是 JAVA 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常见的 Java 类库等\nJRE JRE 是 Java 运行环境，用于运行 Java 的字节码文件。JRE 中包括了 JVM 以及 JVM 工作所需的类库，普通用户只需要安装 JRE 来运行 Java 程序，而程序开发者必须安装 JDK 来编译、调试程序\nJVM JVM 是 Java 虚拟机，是 JRE 的一部分，是整个 Java 实现跨平台最核心的部分，负责运行字节码文件\ne.g. 写 Java 代码，txt 就可以写，但是写出来的代码，想要运行，需要编译成字节码，需要编译器，JDK 中包含编译器 javac，编译折后的字节码想要运行，需要一个可执行字节码的程序，这个程序就是 JVM，专门用来执行 Java 字节码的\n开发需要 JDK\n运行编译好的 Java 字节码文件需要 JRE\nJVM 在执行 Java 字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令有可能是不一样的，导致不同操作系统的 JVM 是不一样的，所以安装 JDK 时要选择操作系统\n另外 JVM 执行的是 Java 字节码，所以只要编译后是 Java 字节码，都可以在 JVM 上运行，比如 Apache Groovy，Scala ， Kotlin 等\nJVM 中，哪些时线程共享区 项目如何排查 JVM 问题 对于还在正常运行的系统 可以使用 jmap 来查看 JVM 中各个区域的使用情况 可以使用 jstack 来查看线程运行情况，比如哪些线程阻塞、是否出现死锁 可以用 jstack 命令来查看垃圾回收的情况，特别是 fullgc，如果发现 fullgc 比较频繁，那么就得进行调优 通过各个命令的结果或 jvisualvm 等工具来进行分析 首先，初步猜测频繁 fullgc 的原因，如过频繁发生 fuulgc 又没有 OOM，那么表示 fuulgc 实际上是回收了很多对象了，所以这些对象最好能在 younggc 过程中就直接回收掉，避免这些对象进入老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入老年代，尝试加大年轻代的大学，如果改完后，fullgc 减少，那么修改有效 同时，还可以找到占用 CPU 最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存 对于已经发生 OOM 的系统 一般生产系统中都会设置当系统发生 OOM 时，生成当时的 dump 文件 可以利用 jsisualvm 等工具来分析 dump 文件 根据 dump 文件找到异常的实例对象，和异常的线程（占用 CPU 高），定位到具体的代码 然后进行详细的分析和调试 总结 调优不是一蹴而就的，需要分析、推理、实践、总结、再分析\nhashCode() 与 equals() 之间的关系 理论 在 Java 中，每个对象都可以调用自己的 hashCode() 方法得到自己的哈希值，相当于对象的指纹信息，通常来说不会有相同的，但 Java 中做不到这样绝对，但我们仍然可以使用 hashCode 来做一些判断\n如果两个对象的 hashCode 不同，这两个对象一定同 如果两个对象的 hashCode 相同，不代表一定是同一个对象 如果两个对象相等，那么 hashCode 一定相同 在 Java 的一些集合类的实现中，在比较两个对象是否相等时，会根据上面的原则，先调用 hashCode() 方法进行比较，如果不同直接判定不同，如果相同进一步调用 equals() 方法。equals() 方法就是来最终确定两个对象是不是相等的。equals() 的实现通常会很重，逻辑较多。\n所以 在我们重写了 equals() 方法时，一定要确保 hashCode() 方法能遵循上述规则\ndemo 演示 未重写 hashCode()\nUser 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 package JAVA.hash_and_equals; import java.util.HashMap; public class TestHashEquals { public static void main(String[] args) { HashMap\u0026lt;User, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(new User(\u0026#34;AKAxedx\u0026#34;), \u0026#34;111\u0026#34;); System.out.println(hashMap.get(new User(\u0026#34;AKAxedx\u0026#34;))); } } 运行结果：null\n原因：hashMap 中的 get 方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param key the key * @return the node, or null if none */ final Node\u0026lt;K,V\u0026gt; getNode(Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n, hash; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; (hash = hash(key))]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { //这里调用了 hash 进行对比 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))// 短路掉了 equals() 方法 return e; } while ((e = e.next) != null); } } return null; } 重写 User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } @Override public int hashCode() { return name.hashCode(); } } 运行结果：111\n== 和 equals 方法的区别 == 如果比较基本数据类型，比较的是值，如果是引用类型，比较的是引用地址 equals() 使用 equals() 方法比较，具体逻辑看具体实现，比如String 类型，虽然是引用类型，但是 String 重写了 equals() 方法，比较的是字符串中各个字符是否相等 String、StringBuffer、StringBuilder的区别 String 是不可变的，如果尝试修改，会生成一个字符串对象，StringBuffer 和 StringBuilder 是可变的 StringBuffer 是线程安全的，StringBuilder 是线程不安全的，单线程环境下 StringBuilder 效率更高 泛型中 extends 和 super 的区别 \u003c? extends T\u003e 表示包括 T 在内的任何 T 的子类 \u003c? super T\u003e 表示包括 T 在内的任何 T 的父类 重载和重写的区别 重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时\n重写 发生在父子类中，方法名，参数列表必须相同，返回值返回小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 private 则不能重写该方法\nList 和 Set 的区别 List 有序，按对象进入的顺序保存对象，可重复，允许多个 Null 元素对象，可以使用 Iterator 取出所有元素，再逐一遍历，还可以使用 get 获取指定下标的元素\nSet 无序，不可重复，最多允许一个 Null 元素对象，取元素时只能使用 Iterator 接口取得所有元素，再逐一遍历\nArrayList 和 LinkedList 的区别 底层数据结构不同，ArrayList 基于数组，而LinkedList 基于链表\n由于底层数据结构不同，他们使用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加。查询、添加、删除的时间复杂度不同\n都是先了 List 接口，而 LinkedList 还而额外实现了 Deque 接口，所以 LinkedList 还能当队列来使用\nConcurrentHashMap 的扩容机制 JDK 1.7版本 ConcurrentHashMap 是基于 Segment 分段实现的 每个 Segment 相当于一个小的 HashMap 每个 Segment 内部会进行扩容，和 HashMap 扩容类似 先生成新的数组，然后转移元素到新数组中 扩容的判断也是每个 Segment 内部单独判断的，判断是否超过阈值 JDK 1.8版本 不再使用 Segment 实现 当某个线程进行 put 时，如果 ConcurrentHashMap 正在扩容，那么该线程一起进行扩容 如果某个线程 put 时，没有在进行扩容，则将 key-value 添加到 ConcurrentHashMap 中，然后判断是否超过阈值，超过进行扩容 ConcurrentHashMap 支持多线程同时扩容 扩容之前生成一个新的数组 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作 JDK1.7-JDK1.8 HashMap 发生了什么变化 JDK1.7 数组 + 链表\n头插法\nhash 算法复杂\nJDK1.8 数组 + 链表 + 红黑树\n红黑树提高插入和查询的整体效率\n尾插法\nhash 算法简化\nHashMap 的 put 方法 大致如下\n通过哈希算法与与运算计算得出数组下标 如果数组下标为空，则将 key-value 封装为 Entry (1.8 版本为 Node) 对象，并放入该位置 如果是 JDK1.7，先判断是否扩容，如果扩容，就进行扩容，不扩容就生成 Entry 对象，使用头插法插入当前位置的链表中 如果是 JDK1.8，先判断该位置上的 Node 的类型（链表、红黑树） 如果是红黑树 Node，将 key-value 封装成一个 红黑树节点并添加进树中（插入/更新） 如果是链表 Node，则将 key-value 封装为一个链表 Node 并通过尾插法插入当前链表尾部，由于尾插进行了遍历，遍历过程中进行插入或更新，如果长度大于 8，将链表转换成红黑树 插入链表或红黑树后才进行判单是否进行扩容 HashMap 的扩容机制 JDK1.7 先生成新数组 遍历老数组的每个位置上的链表的每个元素 取出每个元素的 key，并基于新的数组长度，计算出每个元素再新数组中的下标 将元素添加到新数组中去 所有元素转移完后，将新数组赋值给 HashMap 对象中的 table 属性 JDK1.8 先生成新数组 遍历老数组中的每个位置的链表或红黑树 如果是链表，则直接将链表中的每个元素重新计算下标，添加到新数组中 如果是红黑树，先遍历红黑树，计算每个元素对应的下标位置 统计每个下标位置的元素个数 如果该位置的元素超过了8，生成一个新的红黑树，并将根节点的添加到新数组的对应位置 如果没有超过8，则生成一个链表，将头节点添加到数组的对应位置 所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性 深拷贝和浅拷贝 深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用\n浅拷贝是指，只拷贝基本数据类型的值，以及实例对象的引用地址，不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的属性指向的是同一个对象 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象 CopyOnWriteArrayList 的底层原理 首先 CopyOnWriteArrayList 内部也是数组，在向 CopyOnWriteArrayList 添加元素时，会赋值一个新的数组，写操作在新数组上进行，读操作在原数组上进行 写操作加锁，防止出现并发写入丢失数据的问题 写操作结束之后会把原数组指向新数组 CopyOnWriteArrayList 允许在写操作时来读数据，提高了读的性能，适合多读少写的应用场景，但是 CopyOnWriteArrayList 比较占内存，同时可能读到的数据不是最新的，不适合实时性要求很高的场景 什么是字节码，采用字节码的好处 编译器将 Java 源文件编译成字节码文件，可以做到一次编译到处允许，win 上编译好的 class 文件，可以直接在 linux 上允许，通过这种方式做到跨平台，前提是，不同的操作系统上安装的 JDK 或 JRE 是不同的，虽然字节码通用，但把字节码解释成各个操作系统机器码是需要不同的解释器的，所以各个操作系统需要自己的 JDK 和 JRE\n采用自己尔玛的好处，一方面实现了跨平台，一方面提高了代码执行的性能，编译器在编译源代码时可以做一些编译器的优化，比如锁消除、标量替换、方法内联等\nJava 异常体系 Java 中所有异常都来自顶级父类 Throwable Throwable 下有两个子类 Exception 和 Error Error 表示非常严重的错误，比如 java.lang.StackOverFlowError 和 OOM ，通常这些错误出现时，仅靠程序自己时解决不了的，可能时虚拟机、磁盘、操作系统层面出现了问题，所有通常不建议在代码中去捕获这些 Error，因为捕获的意义不大，因为程序可能已经运行不了了 Exception 表示异常，表示程序出现 Exception 时，是可以靠自己来解决的，比如空指针，数组越界等，我们可以捕获这些异常来进行特殊处理 Exception 的子类通常可分为 RuntimeException 和非 RuntimeException 异常 RuntimeException 表示运行期异常，表示这个异常实在代码运行过程中抛出的，这些事非检查异常，程序中可以选择捕获或直接抛出，这些异常一般是由逻辑错误引起的，程序应该从逻辑角度尽可能避免，比如空指针和数组越界 非 RuntimeException 表示非运行期异常，也即是检查异常，是必须进行处理的异常，如果不处理，程序就不能检查异常通过，如 IOException，SQLException 等以及用户自定义的 Exception 异常 什么时候抛出异常，什么时候捕获异常 异常是一种提示，抛出异常相当于告诉上层方法，我抛出了一个异常，我处理不了，交给你处理。而上层方法他也需要判断能否处理这个异常\n所有在写方法时，要考虑本方法能否合理地处理该异常，处理的了捕获，处理不了抛出\nJava 中有哪些类加载器 BootstrapClassLoader：是ExtClassLoader 的父类加载器，赋值加载 %JAVA_HOME%/lib 下的 jar 包和 class 文件 ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载 %JAVA_HOME%/lib/ext 文件夹下的 jar 包和 class 类 AppClassLoader 是自定义类加载器的父类，负责加载 classpath 下的类文件 类加载器双亲委派模型 JVM 中存在三个默认的类加载器\nBootstrapClassLoader ExtClassLoader AppClassLoader JVM 在加载一个类时，会调用 AppClassLoader 的 loadClass 方法来加载这个类，不管在这个方法中，会先使用 ExtClassLoader 的 loadClass 方法来加载类，同样 ExtClassLoader 的 loaderClass 会使用 BootstrapClass 的 loaderClass 方法来加载类，如果 BootstrapClassLoader 加载到了直接成功，如果没有则 ExtClassLoader 加载，如果还没有则 AppClassLoader 加载\n所以，双亲委派指的是，JVM 在加载类时，会委派给父类加载，没加载到才自己进行加载\n一个对象加载到 JVM，再到被 GC 清除，都经历了什么过程 首先把字节码文件内容加载到方法区 根据类信息再堆区创建对象 对象首先会分配再堆区中年轻代的 Eden 区，经过一次 Minor GC 后，如果对象存活，进入 Suvivor 区，在后续的每次 Minor GC中，如果对象一直存活，就会在 Suvivor 区来回拷贝，没移动一次，年龄加1 当年龄超过15后，对象依然存活，对象进入老年代 如果经过 Full GC，被标记为垃圾对象，那么就会被 GC 线程清理掉 怎么确定一个对象到底是不是垃圾 引用计数法：这种方式时给堆内存当中每个对象记录一个引用个数，引用个数为0的就认为是垃圾，这是早期 JDK 中使用的方法，引用计数无法解决循环引用的问题 可达性算法：这种方法是再内存中，从根对象一直向下找引用，找到的对象就不是垃圾，没找的是垃圾 JVM 有哪些垃圾回收算法 标记清除算法： 标记阶段：把垃圾内存标记出来 清除阶段：直接将垃圾内存回收 赭红算法简单，但会产生大量内存碎片 复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法，复制算法将内存分为大小相等的两半，每次只是用其中一半，垃圾回收时，将当前这一块的内存活对象全部拷贝到另一半，然后这一半直接清除，这种算法没有内存碎片，但是浪费空间 标记压缩法：为了解决复制算法的缺陷，提出标记压缩法，这张算法在标记阶段和清除算法一样，标记完后，不直接清除垃圾，而是将存活对象往一端移动，然后将边界外的所有内存清除 什么是 STW Stop-The-World，实在垃圾回收算法执行过程当中，需要将 JVM 内存冻结的一种状态，在 STW 状态下，Java 所有线程都是停止执行的-GC线程除外，native 方法可以执行，但是，不能与 JVM 交互，GC 各种算法优化的重点，就是减少 STW，这也是 JVM 调优的重点\nJVM 参数有哪些 绝大数情况下，常用的有十来个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # JVM 启动参数不换行 # 设置堆内存 -Xmx4g -Xms4g # 指定 GC 算法 -XX:+UseG1GC -XX:MaxGCPauseMillis=50 # 指定 GC 并行线程数 -XX:ParallelGCThreads=4 # 打印 GC 日志 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 指定 GC 日志文件 -Xloggc:gc.log # 指定 Meta 区的最大值 -XX:MaxMetaspaceSize=2g # 设置单个线程栈的大小 -Xss1m # 指定堆内存溢出时自动进行 Dump -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ","date":"2024-08-25T05:53:40+08:00","image":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/698503_hu14773505816458707756.jpg","permalink":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/","title":"Java 基础"},{"content":"备战秋招 JAVA 基础 包含 Java SE、JUC 等 Java 语言相关的特性\n具体地址\nTomcat 包含 Tomcat 相关的面试题\n具体地址\n计网基础 具体地址\nSpring 具体地址\n","date":"2024-08-25T05:44:46+08:00","image":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B_hu13581451615509590227.PNG","permalink":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/","title":"备战秋招"},{"content":"\n","date":"2024-08-25T02:25:02+08:00","image":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/image-20240825022846591_hu11050290388165439678.png","permalink":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","title":"Spring 源码解析笔记"}]