[{"content":"数据库相关 Mybatis 的优缺点 优点 基于 SQL 语言编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，基础 SQL 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用 与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接 很好的与各种数据库兼容（因为 Mybatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 Mybatis 都支持） 能够与 Spring 很好的集成 提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护 缺点 SQL 语句的编写工作量大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求 SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库 #{} 和 ${} 的区别 #{} 是预编译处理、是占位符，${} 是字符串替换、是拼接符\nMybatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ? ，调用 PreparedStatement 来赋值\nMybatis 在处理 ${} 时，会将 SQL 中的 ${} 替换成变量的值，调用 Statement 来赋值\n使用 #{} 可以有效地防止 SQL 注入，提高系统安全性\n索引的基本原理 索引用来快速地寻找那些具有特定值的记录，如果没有索引，一般来说执行查询时遍历整张表\n索引的原理：就是把无序的数据编程有序的查询\n把创建了索引的列的内容进行排序 对排序结果生成倒排表 在倒排表内容上拼上数据地址链 在查询时先拿到倒排表内容，再取出数据的地址链，从而拿到具体数据 索引设计的原则 查询更快，占用空间更小\n适合索引的列时出现再 where 子句中的列，或者连接子句中指定的列 基数较小的类，索引效果较差，没必要在此列建立索引 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配 不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。再修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个事件就会越长。所以只要保持需要的索引有利于查询即可 定义有外键的数据列一定要建立索引 更新频繁字段不适合创建索引 若是不能有效区分数据的列不适合做索引列（如性别） 尽量的扩展索引，不要新建索引，比如表中已经有 a 的索引，现在要加 (a,b) 的 索引，那么只需要修改原来的索引即可 对于哪些查询中很少涉及的列，重复值比较多的列不要建立索引 对于定义为 text、image 和 bit 的数据类型的列不要建立索引 事务的基本特性和隔离级别 事务基本特性 ACID 原子性 指的是一个事务中的操作要么全部成功，要么全部失败\n一致性 指的是数据库总是从一个一致性的状态转换到另一个一致性的状态。比如 A 转账给 B 100 元，假设 A 只有 90 元，支付之前我们数据库里的数据都是符合约束的，但是如果事务执行成功，数据库数据就破坏约束了，因此事务不能成功\n隔离性 指的是一个事务的修改再最终提交前，对其他事务是不可见的\n持久性 指的是一旦事务提交，所做的修改就会永久保存到数据库中\n隔离性的四个隔离级别 read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读，用户本来应该读取到 id = 1的用户 age 应该是 10，结果读到了其他事务还没有提交的事务，结果读取结果 age = 20，这就是脏读 read commit 读已提交，两次读取结果不一致，也叫不可重复读，不可重复读解决了脏读的问题，他只会读取已经提交的事务。用户开启事务读取 id = 1的用户，查询到 age = 10，再次读取发现结果未 20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读 repeatable read 可重复读，mysql 默认级别，每次读取结果都一样，但是可能产生幻读 serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题 什么是 MVCC 多版本并发控制，指的是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务在执行普通 SELECT 操作时访问记录的版本链的过程。可以使用不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大的不同是：生成 ReadView 的时机不同，READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView\nMyISAM 和 InnoDB 的区别 MyISAM 不支持事务，但是每次查询都是原子的 支持表级锁，每次操作对整个表加锁 存储表的总行数 一个 MyISAM 表有三个文件：索引文件，表结构文件，数据文件 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性 InnoDB 支持 ACID 的事务 支持事务的四种隔离级别 支持行级锁以及外键约束，因此可以支持写并发 不存储行总数 一个 InnoDB 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件中），也可能未多个（设置为独立表空间，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+ 树结构，文件的大调整 Explain 语句结果中各个字段分别表示什么 列名 描述 id 查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样 select_type SELECT 关键字对应的那个查询类型 table 表名 partitions 匹配的分区信息 type 针对单表的查询方式（全表扫描、索引） possible_keys 可能用到的索引 key 实际上使用的索引 ken_len 实际上使用的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filterte 某个表经过 搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息，比如排列 索引覆盖是什么 索引覆盖就是一个 SQL 再执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包含了，那么就表示此 SQL 走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回\n最左前缀原则 当一个 SQL 想要利用索引时，就一定要提供该索引锁对应的字段中最左边的字段，也iu是排在最前面的字段，比如针对 a,b,c 三个字段建立了一个联合索引，那么在写以恶搞 SQL 时就一定要提供 a 字段的条件，这样才能用到联合索引，这是由于建立 a,b,c 三个字段的联合索引时，底层的 B+ 树时按照 a,b,c 三个字段从左往右去比较大小进行排序的，所以如果想要利用 B+ 树进行快速查找也得符合这个规则\nInnoDB 是如何实现事务的 InnoDB 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 update 语句为例\nInnoDB 在收到一个 update 后，会先根据条件找到数据所在的也，并将该页缓存在 Buffer Pool 中 执行 update 语句，修改 Buffer Pool 重点数据，也就是内存中的数据 针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中 针对 update 语句生成 undolog 日志，用于事务回滚 如果事务提交，那么把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中 如果事务回滚，那么利用 undolog 日志进行回滚 B 树和 B+ 树的区别，为什么 Mysql 使用 B+ 树 B 树的特点\n节点排序 一个节点可以存放多个元素 B+ 树的特点\n拥有 B 树的特点 叶子节点之间有指针 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好序 Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 树通过对数据进行 排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使 B+ 树的高度不会太高，在 Mysql 中一个 InnoDB 页就是一个 B+ 树节点，一个 InnoDB 页默认 16kb，所以一般情况下一棵两层的 B+ 树可以存 2000万行左右的数据，然后利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子几点之间有指针，可以很好的支持全表扫描，范围查找等 SQL\nMysql 锁有哪些，如何理解 按粒度分类\n行锁：锁某行数据，锁粒度最小，并发度高 表锁：锁整张表，锁粒度最大，并发度低 间隙锁：锁的是一个区间 按读写分\n共享锁：读锁，一个事务给某行数据加了读锁，其他事务可以读，但不能写 排他锁：写锁，一个事务给某行数据加了写锁，其他事务不能读不能写 按实现方式\n乐观锁：不会真正去锁某行记录，通过一个版本号来实现 乐观锁：上面的行锁、表锁都是悲观锁 在事务的隔离级别实现中，就需要利用锁来解决幻读\nRDB 和 AOF RDB Redis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储\n优点：\n整个 Redis 数据库将只包含一个文件 dump.rdb，方便持久化 容灾性号，方便备份 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能 相对于数据集大是，比 AOF 的启动效率更高 缺点：\n数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟 AOF Append Only File，以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录\n优点：\n数据安全，Redis 中提供了 3 种同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现当即现象，那么这一秒钟之内修改的数据将会丢失，而每修改同步，可以视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中 通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题 AOF 机制的 rewrite 模式。定期对 AOF 文件进行重写，达到压缩的目的 缺点：\nAOF 文件比 RDB 文件大，且恢复速度慢 数据集大的时候，比 RDB 启动效率低 运行效率没有 RDB 高 Redis 的过期键的删除策略 Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。Redis 的过期策略就是指当 Redis 中缓存的 key 过期了，Redis 如何处理\n惰性过期：只有当访问一个 key 时，才会判断该 key 是否已经过期，过期则清除。该策略可以最大化节省 CPU 资源，对内存不友好，极端情况下可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存 定时过期（Redis 没使用）：实时监控过期时间，对内存友好，对 CPU 不友好 定期过期：每隔一段时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已经过期的 key。该策略是前两者的折中方案。通过调整定时扫描的 时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果 Redis 事务实现 事务开始 MULTI 命令的执行，标志着一个事务的开始。MULTI 命令会将客户端状态的 flags 属性中的 REDIS_MULTI 标识打开、 命令入队 当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为 MULTI、EXEC、WATCh、DISCARD 中的一个，立即执行这个命令，否则将命令放入一个事务队列里，然后向客户端返回 QUEUED 回复 如果客户端发送的命令为 EXEC、DISCARD、WATCh、MULTI 四个命令中的一个，那么服务器立即执行这个命令 如果发送到是其他命令，服务器并不立即执行这个命令。首先检查命令格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并返回错误信息给客户端。如果正确，将这个命令放入一个事务队列里，然后返回 QUEUED 回复 事务队列是按照 FIFO 的方式保存入队命令 事务执行 客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑 如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行 否则客户端处于事务状态（flags 有 REDIS_MULTI标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返给客户端 redis 不支持事务回滚机制，但是他会检查每一个事务中的命令是否错误 redis 事务不支持检查程序员自己逻辑的错误 WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令 MULTI 命令用于开启一个事务，它总是返回 OK。MuLTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 被调用时，所有队列中的命令才会被执行 EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态退出 UNWATCH 命令可以取消 WATCH 对所有 key 的监控 Redis 主从复制的核心原理 ","date":"2024-09-02T10:17:38+08:00","image":"https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber_hu4745314353014532042.jpg","permalink":"https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/","title":"数据库相关"},{"content":"Spring 谈谈 IOC IOC - 控制反转\n什么是控制，控制了什么 我们在使用 Spring 时，会建一些类，比如 UserService\n使用一些注解，比如 @Autowired\n但是，当程序运行时，用的是具体的 UserService 对象，那么这些对象是什么时候创建的，谁创建的，对象里的值哪里来的，这些都是 Spring 做的\n这就是控制\n控制对象的创建 控制对象内属性的赋值 什么是反转 如果我们不使用 Spring，就需要我们自己创建对象以及赋值，反过来，Spring 帮我们做这些，这就是 反转，表示一种 对象控制权 的转移\n反转有什么用，为什么反转 如果我们自己负责创建对象，自己赋值，会出现什么情况\n比如现在有三个类\nA 类，A 类里有一个属性 C c B 类，B 类里也有一个属性 C c C 类 现在程序要运行，这三个类的对象都要创建出来，并且相应的属性要有值，那么除开定义这三个类，我们还需要写\nA a = new A() B b = new B() C c = new C() a.c = c b.c =c 我们会多些很多业务代码，而且随着属性变多，类变多，代码会变得异常复杂，将这些工作交给 Spring，减轻了程序员的负担\n总结 IoC 表示控制反转，表示如果使用 Spring，那么 Spring 会负责来创建对象，以及给对象内的属性赋值，也就是如果用 Spring，那么对象的控制权将转交给 Spring\n单例 Bean 和单例模式 单例模式表示 JVM 中某个类的对象只会存在一个\n单例 Bean 并不表示 JVM 中只能存在唯一的某个类的对象\n单例 Bean ，使用同一个名字能拿到同一个对象，但我可以 new 出来很多个该对象取不同的名字\nSpring 中的事务是如何实现的 Spring 事务底层是基于数据库事务和 AOP 机制的 首先对于使用了 @Transactional 注解的 Bean，spring 会创建一个代理对象作为 Bean 当调用代理对象的方法时，会先判断该方法上是否加了 @Transactional 注解 如果加了，那么则利用事务管理器创建一个数据库连接 并且修改数据库连接的 autocommit 属性为 false，禁止此连接的自动提交，这是实现 Spring 事务非常重要的一步 然后执行当前方法，方法中会执行 sql 执行完当前方法后，如果没有出现异常就直接提交事务 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务 Spring 事务的隔离级别对应的就是数据库的隔离级别 Spring 事务的传播机制是 Spring 事务自己实现的，也是 Spring 事务中最复杂的 Spring 事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行 sql Spring 事务传播机制 多个事务方法相互调用时，事务如何在这些方法间传播，方法 A是一个事务的方法，方法 A 执行过程中调用了方法 B，那么方法 B 有无事务以及方法 B 对事务的要求不同都会对方法 A 的事务具体执行造成影响，同时方法 A 的事务对方法 B 的事务执行也有影响，这种影响具体是什么就由这两个方法所定义的事务传播类型所决定\nREQUIRED（Spring 默认的事务传播类型）：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务 SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行 MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常 REQUIRED_NEW：创建一个新事物，如果当前存在事务，则挂起该事务 NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务 NEVER：不使用事务，如果当前事务存在，则抛出异常 NESTED：如果当前事务存在，则在嵌套事务中执行，否则开启一个事物 Spring 事务什么时候会失效 spring 事务的原理是 AOP，进行了切面增强，那么失效的根本原因是这个 AOP 不起作用了，常见情况有以下几种\n发生自调用，类里面使用 this 调用本类的方法（this 通常省略），此时这个 this 对象不是代理类，而是 UserService 对象本身 方法不是 public 的：@Transactional 只能用于 public 方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式 数据库不支持事务 没有被 spring 管理 异常被吃掉事务不会回滚（或抛出的一场没有被定义，默认 RuntimeException） Spring 中 Bean 是线程安全的吗 Bean 本质上还是一个对象\nSpring 本身没有针对 Bean 做线程安全的处理，所以\n如果 Bean 是无状态的，那么 Bean 是线程安全的 如果 Bean 是有状态的，那么 Bean 是线程不安全的 （有状态：Bean 里的属性会变化，Setter方法）\n另外，Bean 是不是线程安全，跟 Bean 的作用域没有关系，Bean 的作用域只是表示 Bean 生命周期范围，对于任何生命周期的 Bean 都是一个对象，这个对象是不是线程安全的，还是得看这个 Bean 对象本身\nSpring 中的 Bean 创建的生命周期有哪些步骤 推断构造方法 实例化 填充属性（依赖注入） 处理 Aware 回调 初始化前，处理 @PostConstruct 注解 初始化，处理 InitializingBean 接口 初始化后，进行 AOP ApplicationContext 和 beanFactory 有什么区别 BeanFactory 是 Spring 中非常核心的组件，表示 Bean 工厂，可以生成 Bean，维护 Bean，而 ApplicationContext 继承了 BeanFactory，所以 ApplicationContext 拥有 BeanFactory 所有的特点，也是一个 Bean 工厂，但是 ApplicationContext 除开继承了 BeanFactory 之外，还继承了诸如 EnvironmentCapable、MessageSource、ApplicationEventPublisher 等接口，从而 ApplicationContext 还有获取系统环境变量、国际化、事件发布等功能，这是 BeanFactory 所不具备的\n1 public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver 这里 ApplicationContext 不仅继承了 ListableBeanFactory，还继承了环境变量操作的接口\nEnvironmentCapable ，国际化 MessageSource 等接口\nSpring 容器启动流程是怎样的 在创建 Sprig 容器，也就是启动 Spring 时 首先会进行扫描，扫描得到所有的 BeanDefinition 对象，并存在一个 Map 中 然后筛选出非懒加载的单例 BeanDefinition 进行创建 Bean，对于多例 Bean 不需要再启动过程中去进行创建，对于多例 Bean 会在每次获取 Bean 时利用 BeanDefinition 去创建 利用 BeanDefinition 创建 Bean 就是 Bean 的创建生命周期，这期间把包括了合并 BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中 AOP 就是发生再初始化后这一步骤中 单例 Bean 创建完了之后， Spring 会发布一个容器启动事件 Spring 启动结束 在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些 BeanFactoryPostProcessor 和 BeanPostprocessor 的注册，Spring 的扫描就是通过 BeanFactoryPostProcessor 来实现的，依赖注入就是通过 BeanPostprocessor 来实现的 在 Spring 启动过程中还回去处理 @Import 等注解 Spring Boot 中常用注解及其底层实现 @SpringBootApplication 注解：这个注解标识了一个 SpringBoot 工程，它实际上是另外三个注解的组合 @SpringBootConfiguration：这个注解实际上就是以恶搞 @Configuration，表示启动类也是一个配置类 @EnableAutoConfiguration：向 Spring 容器中导入了一个 Selector，用来加载 ClassPath 下 SpringFactories 中所定义的自动配置类，将这些自动加载为配置 Bean @ComponentScan：标识扫描路径，因为默认是没有配置实际扫描路径，所以 SpringBoot 扫描的路径是启动类所在的当前目录 @Bean 注解：用来定义 Bean，类似于 XML 中的 标签，Spring 在启动时，会对加了 @Bean 注解的方法进行解析，将方法的名字作为 beanName，并通过执行方法得到 bean 对象 @Controller、@Service、@ResponseBody、@Autowired Spring Boot 是如何启动 Tomcat的 首先，SpringBoot 在启动时会先创建一个 Spring 容器 在创建 Spring 容器过程中，会利用 @ConditionalOnClass 技术来判断当前 classpath 中是否存在 Tomcat 依赖，如果存在则会生成一个启动 Tomcat 的 Bean Spring 容器创建完后，就会获取激动 Tomcat 的 Bean，并且创建 Tomcat 对象，并绑定端口等，然后启动 Tomcat ","date":"2024-08-30T17:59:49+08:00","image":"https://akaxedx.github.io/p/spring/saber_hu3822888719987798397.jpg","permalink":"https://akaxedx.github.io/p/spring/","title":"Spring"},{"content":"计网基础 描述下 HTTP 和 HTTPS 的区别 HTTP：互联网上应用最为广泛的一种网络通信协议，基于 TCP，可以使浏览器工作更为高效，减少网络传输 HTTPS：是 HTTP 的加强版，可认为是 HTTP + SSL（Secure Socket Layer）。在 HTTP 的基础上增加了一系列的安全机制。一方面保证数据传输安全，另一方面对网文者增加了验证机制。是目前现行架构下，最为安全的解决方案 主要区别 HTTP 的连接是简单无状态的，HTTPS 的数据传输是经过证书加密的，安全性更高 HTTP 是免费的，HTTPS 需要申请证书，证书通常需要收费，费用一般不低 他们的传输协议不同，所使用的端口也不同，HTTP 默认80端口，HTTPS 默认是 443 HTTPS 的缺点\nHTTPS 的握手协议比较费时，所以会影响服务的相应速度以及吞吐量 HTTPS 也并不是完全安全的。他的证书体系起始并不完全安全，HTTPS 在面对 DDOS 的攻击时，几乎起不到任何作用 功能越强大的证书费用越高 Cookie 和 Session 的区别 当服务器 tomcat 第一次接收到客户端请求时，会开辟一块独立的 session 空间，建立一个 session 对象，同时会生成一个 session id，通过响应头的方式保存到客户端浏览器的 cookie 当中。以后客户端每次请求，都会在请求头部带上这个 session id，这样可以对应上服务端的一些会话的相关信息，比如用户的登录状态\n如果没有客户端的 Cookie，Session 是无法进行身份验证的\n当服务端从单体应用升级为分布式之后，cookie + session 这种机制要怎么扩展\nsession 黏贴：在负载均衡中，通过一个机制保证所有的请求都会转发到同一个 tomcat 实例中。问题：当这个 tomcat 实例出现问题后，请求会被转发到其他实例，这时候用户的 session 信息丢失 session 复制：当一个 tomcat 实例上保存了 session 信息后，主动将 session 复制到集群中的其他实例。问题：复制需要时间，在复制过程中，容易产生 session 信息丢失 session 共享：将服务端的 session 信息保存到一个第三方中，比如 redis。可实现单点登录 BIO，NIO，AIO 分别是什么 BIO：同步阻塞 IO，使用 BIO 读取数据，线程会阻塞住，并且需要线程主动去查询是否有数据可读，并且需要处理完一个 Socket 之后才能处理下一个 Socket NIO：同步非阻塞 IO，使用 NIO 读取数据时，线程不会阻塞，但需要线程主动去查询是否有 IO 事件 AIO：也叫 NIO2.0，异步非阻塞 IO，使用 AIO 读取数据时，线程不会阻塞，并且当有数据可读时会通知给线程，不需要线程主动去查询 Netty 的高性能体现在哪些方面 NIO 模型，用最少的资源做更多的事情 内存零拷贝，尽量减少不必要的内存拷贝，实现了更高效率的传输 内存池设计，申请的内存可以重用，主要指直接内存，内部实现使用一颗二叉查找树管理内存分配情况 串行化处理读写：避免使用锁带来的性能开销。即消息的处理尽可能在同一个线程内完成，期间不进行线程切换。这样避免了多线程竞争和同步锁。表面上看，串行化设计似乎 CPU 利用率不高，但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列+对各工作线程模型性能更优 高性能序列化协议：支持 protobuf 等高性能序列化协议 高效并发编程的体现：volatile 的大量、正确使用。CAS 和原子类的管饭使用，线程安全容器的使用，通过读写锁提升开发性能 ","date":"2024-08-29T20:13:09+08:00","image":"https://akaxedx.github.io/p/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/saber_hu3120267142170166617.jpg","permalink":"https://akaxedx.github.io/p/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/","title":"计网基础"},{"content":"Tomcat Tomcat 中为什么要使用自定义类加载器 一个 Tomcat 中可以部署很多个应用，而每个应用中都存在很多类，各个应用中的类是独立的，全类名是可以相同的。一个 Tomcat 不管内部部署了多少应用，Tomcat 启动之后就是一个 Java 进程，也就是一个 JVM，所以如果 Tomcat 中只存在一个类加载器，比如默认的 AppClassLoader，那么只能加载一个同名类，这是有问题的。在 Tomcat中，会为部署的每个应用都生成一个类加载器实例，叫做 WebAppClassLoader，这样 Tomcat 中每个应用都可以使用自己的类加载器去加载自己的类，实现应用之间的类隔离，不出现冲突。另外 Tomcat 还利用自定义加载器实现了热加载的功能\n","date":"2024-08-25T18:10:13+08:00","image":"https://akaxedx.github.io/p/tomcat/saber_hu18427175924411022449.jpg","permalink":"https://akaxedx.github.io/p/tomcat/","title":"Tomcat"},{"content":"Java 基础 JUC 对线程安全的理解 线程安全指的是，我们写的某段代码，在多个线程同时执行时，不会产生混乱，依然能够得到正常的结果，比如 i++，初始化为0，那么两个线程来同时执行这行代码，如果代码时线程安全的，那么最终结果应该就是一个线程的结果为1，一个线程结果为2，如果出现了两个线程结果都为1，则表示这段代码线程不安全\n对守护线程的理解 线程分为用户线程和守护线程，用户线程就是普通线程，守护线程时 JVM 的后台线程，比如垃圾回收线程就是一个守护线程，守护线程会在其他普通线程都停止运行后自动关闭，我们可以通过设置 thread.setDaemon(true) 来把一个线程设置为守护线程\n并发、并行、串行之间的区别 串行：一个任务执行完，才能执行下一个 并行：两个任务同时执行 并发：两个任务看上去是同时执行的，但实际上是任务被分成了很多分，然后一个一个执行 Java 避免死锁 造成死锁的原因 一个资源每次只能被一个线程使用 一个线程在阻塞等待某个资源时，不释放已占有资源 一个线程已经获得资源，在未使用完之前，不能强行剥夺 若干线程形成头尾相接的循环等待资源关系 这是形成死锁的必须达到的四个条件，只要不满足其中一个，就能避免死锁的形成，而前三个是作为锁的必要条件，所有打破第四个条件，不出现循环等待锁的关系\n开发注意事项 注意加锁顺序，保证每个线程按同样的顺序进行加锁 注意加锁时限，可以针对锁设置超时时间 注意死锁检查，确保在第一时间发现死锁并解决 Java 中创建线程的方式 继承Thread类 1 2 3 4 5 6 7 8 9 10 11 public class TestThread extends Thread{ public static void main(String[] args) { TestThread thread = new TestThread(); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 由于 Java 是单继承，直接继承 Thread 会限制继承其他类，因此多用 Runnable 接口实现多线程 Thread 也是继承了 Runnable 接口的类，本质上还是等于继承了 Runnable 接口 实现Runnable接口 1 2 3 4 5 6 7 8 9 10 11 public class TestRunnable implements Runnable{ public static void main(String[] args) { Thread thread = new Thread(new TestRunnable()); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 匿名内部类实现多线程\n1 2 3 4 5 6 7 8 9 10 11 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } }); thread.start(); } } 使用 lambda 表达式简化\n1 2 3 4 5 6 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(() -\u0026gt; System.out.println(\u0026#34;111\u0026#34;)); thread.start(); } } 实现 Callable 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestCallable implements Callable\u0026lt;String\u0026gt; { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(new TestCallable()); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); System.out.println(result); } @Override public String call(){ return \u0026#34;111\u0026#34;; } } 与 Runnable 的区别在于可以拿到线程执行的结果，这里需要与 FutureTask 结合使用 而 FutureTask 是继承的 Runnable 接口和 Future 接口的接口 线程池创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestThreadPool implements Runnable{ public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new TestThreadPool()); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 总结 以上四种方式底层均为 Runnable 接口\n线程池底层工作原理 线程池内部通过队列+线程实现的，我们利用线程池执行任务时\n如果此时线程池中的线程数量小于 corePoolSize，即线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务 如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue 未满，那么任务被放入缓冲队列 如果此时线程池中的线程数量大于等于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量小于 maximumPoolSize，建新的线程来处理被添加的任务 如果此时线程池中的线程数量大于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量等于 maximumPoolSize，那么通过 handler 所指定的策略来处理此任务 当线程池中的线程数量大于 corePoolSize，如果某线程空闲时间超过 keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数 线程池为什么是先添加队列而不是先创建最大线程 当线程池中的核心线程都在忙时，如果继续往线程池中添加任务，那么任务会先入队列，队列满了之后，才会开新线程。相当于一个公司有十个员工，本来十个员工可以正常处理各种需求，但是随着共公司的发展，需求在慢慢增加，但是一开始这些需求只会增加在待开发列表中，然后这十个员工从待开发列表中获取任务进行处理，但是某一天开发列表满了，十个员工彻底处理不过来了，才会招收新员工\n不建议使用 Executors 创建线程池的原因 FixedThreadPool 当我们使用 Executors 创建 FixedThreadPool 时，对应的构造方法为\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 这里 LinkedBlockingQueue 是一个无界的阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加进队列，会有 OOM 的风险 SingleThreadExecutor 当我们使用 Executors 创建 SingleThreadExecutor 时，对应的构造方法为\n1 2 3 4 5 6 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } 也是 LinkedBlockingQueue 总结 除了 OOM 的风险外，我们使用 Executors 来创建线程池也不能自定义线程的名字，不利于排查问题，所以应该用 ThreadPoolExecutor 直接定义线程池，可以灵活控制\n线程池有哪几种状态，每种状态分别表示什么 RUNNING 表示线程池正常运行，既能接收新任务，也会正常处理队列中的任务\nSHUTDOWN 当调用线程池 shutdown() 方法时，进入 SHUTDOWN 状态，表示线程池正处于关闭状态，不会接收新任务，但会继续把队列中的任务处理完\nSTOP 当调用线程池 shutdownnow() 方法时，线程池进入 STOP 状态，表示线程池正处于停止状态，此状态 不会接收新任务，也不会处理队列中的任务，正在运行的线程也会终断\nTIDYING 线程池中没有线程运行后，线程池状态自动变为 TIDYING，并且调用 terminated()，该方法是空方法，可以自行扩展\nTERMINATED terminated() 方法执行完后，线程池状态变为 TERMINATED\nSynchronized 和 ReentrantLock Synchronized ReentrantLock Java 中的一个关键值 JDK 提供的一个类 自动加锁与释放锁 手动加锁与释放 JVM 层面的锁 API 层面的锁 非公平锁 公平锁或非公平锁 锁的是对象，锁信息保存在对象头中 int 类型的 state 标识来标识锁的状态 底层有锁升级的过程 没有锁升级的过程 ReentrantLock 分为公平和非公平锁，底层是怎么实现的 首先，不管是公平锁还是非公平锁，他们的底层实现都会用 AQS 来进行排队，他们的区别在于线程在使用 lock() 方法加锁时：\n公平锁：检查 AQS 队列中是否存在线程在排队，如果有，则当前线程也进行排队 非公平锁：不检查是否排队，直接竞争锁 总结 不管是否是公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁知识体现在的线程加锁阶段，而没有体现在线程被唤醒阶段\nReentrantLock 是可重入锁，不管是否公平\nReentrantLock 中 tryLock 和 lock 方法的区别 tryLock 表示尝试加锁，可能加到可能加不到。该方法不会阻塞线程，加到返回 true，没有返回 false lock 表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值 CountDownLatch 和 Semaphore 的区别和底层原理 CountDownLatch CountDownLatch 表示计数器，可以给 CountDownLatch 设置一个数字，一个线程调用 CountDownLatch 的 await() 将会阻塞，其他线程可以调用 CountDownLatch 的 countDown() 方法来对 CountDownLatch 中的数字减一，当数字为 0 后，所有 await 的线程将会被唤醒\n原理：待用 await() 方法的线程会利用 AQS 排队，一旦数字被减为0，则会将 AQS 中排队的线程依此唤醒\nSemaphore Semaphore 表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过 acquire() 来获取许可，如果没有许可可用则线程阻塞，并通过 AQS 来排队，可以通过 release() 方法来释放许可，当某个线程释放了某个许可后，会从 AQS 中正在排队的第一个线程一次唤醒，直到没有空闲许可\n谈谈对 AQS 的理解，AQS 如何实现可重入锁 AQS 时一个 Java 线程同步的框架，是 JDK 中很多锁工具的核心实现框架 在 AQS 中，维护了一个信号量 state 和一个线程组成的双向链表队列，其中，这个线程队列，就是用来给线程排队用的，而state 就像是一个红绿灯，用来控制线程排队或者放行的，在不同场景下有不同的意义 在可重入锁这个场景下，state 就用来表示加锁次数，0表示无锁，每加一次锁，state 就加1，释放减1 Synchronized 锁是怎么升级的 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程 ID，该线程下次如果又来获取该锁就可以直接获取到了，也就是支持锁重入 轻量级锁：有偏向锁升级，当一个线程获取到锁后，此时这把锁是偏向锁，此时又有第二个线程来竞争锁，偏向锁会升级为轻量级锁，轻量级锁通过自旋实现，不会阻塞线程 自旋次数过多仍没有获取到锁，则会升级成重量级锁，重量级锁会导致线程阻塞 自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较耗费时间，自旋锁是线程通过 CAS 获取预期的一个标记，如果没获取到则循环获取，这个过程线程一直在运行中，没有使用太多操作系统资源，比较轻量 ThreadLocal的应用场景，底层实现是什么样的 ThreadLocal 底层 ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利用该机制将数据 缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据 ThreadLocal 底层是通过 ThreadLocalMap 实现的，每个 Thread 对象中都存在一个 ThreadLocalMap，Map 的 key 为 Threadlocal 对象，Map 的 value 为需要缓存的值 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestThreadLocal { private ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public void a() { local.set(\u0026#34;111\u0026#34;); b(); } public void b() { String s = local.get(); System.out.println(s); } } 在线程池中使用 ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使用完后，应该把设置的 key，value 也就是 Entry 对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap，ThreadLocalMap 也是通过强引用指向 Entry 对象，线程不被回收，Entry 对象也就不会回收，从而出现内存泄漏。解决方法是，在使用 ThreadLocal 对象后，手动调用 ThreadLocal d remove 方法，手动清除 Entry 对象 应用场景 一个经典的场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接）\nJava 核心类库及其底层原理 JDK，JRE，JVM之间的区别 JDK JDK 是 JAVA 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常见的 Java 类库等\nJRE JRE 是 Java 运行环境，用于运行 Java 的字节码文件。JRE 中包括了 JVM 以及 JVM 工作所需的类库，普通用户只需要安装 JRE 来运行 Java 程序，而程序开发者必须安装 JDK 来编译、调试程序\nJVM JVM 是 Java 虚拟机，是 JRE 的一部分，是整个 Java 实现跨平台最核心的部分，负责运行字节码文件\ne.g. 写 Java 代码，txt 就可以写，但是写出来的代码，想要运行，需要编译成字节码，需要编译器，JDK 中包含编译器 javac，编译折后的字节码想要运行，需要一个可执行字节码的程序，这个程序就是 JVM，专门用来执行 Java 字节码的\n开发需要 JDK\n运行编译好的 Java 字节码文件需要 JRE\nJVM 在执行 Java 字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令有可能是不一样的，导致不同操作系统的 JVM 是不一样的，所以安装 JDK 时要选择操作系统\n另外 JVM 执行的是 Java 字节码，所以只要编译后是 Java 字节码，都可以在 JVM 上运行，比如 Apache Groovy，Scala ， Kotlin 等\nJVM 中，哪些时线程共享区 项目如何排查 JVM 问题 对于还在正常运行的系统 可以使用 jmap 来查看 JVM 中各个区域的使用情况 可以使用 jstack 来查看线程运行情况，比如哪些线程阻塞、是否出现死锁 可以用 jstack 命令来查看垃圾回收的情况，特别是 fullgc，如果发现 fullgc 比较频繁，那么就得进行调优 通过各个命令的结果或 jvisualvm 等工具来进行分析 首先，初步猜测频繁 fullgc 的原因，如过频繁发生 fuulgc 又没有 OOM，那么表示 fuulgc 实际上是回收了很多对象了，所以这些对象最好能在 younggc 过程中就直接回收掉，避免这些对象进入老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入老年代，尝试加大年轻代的大学，如果改完后，fullgc 减少，那么修改有效 同时，还可以找到占用 CPU 最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存 对于已经发生 OOM 的系统 一般生产系统中都会设置当系统发生 OOM 时，生成当时的 dump 文件 可以利用 jsisualvm 等工具来分析 dump 文件 根据 dump 文件找到异常的实例对象，和异常的线程（占用 CPU 高），定位到具体的代码 然后进行详细的分析和调试 总结 调优不是一蹴而就的，需要分析、推理、实践、总结、再分析\nhashCode() 与 equals() 之间的关系 理论 在 Java 中，每个对象都可以调用自己的 hashCode() 方法得到自己的哈希值，相当于对象的指纹信息，通常来说不会有相同的，但 Java 中做不到这样绝对，但我们仍然可以使用 hashCode 来做一些判断\n如果两个对象的 hashCode 不同，这两个对象一定同 如果两个对象的 hashCode 相同，不代表一定是同一个对象 如果两个对象相等，那么 hashCode 一定相同 在 Java 的一些集合类的实现中，在比较两个对象是否相等时，会根据上面的原则，先调用 hashCode() 方法进行比较，如果不同直接判定不同，如果相同进一步调用 equals() 方法。equals() 方法就是来最终确定两个对象是不是相等的。equals() 的实现通常会很重，逻辑较多。\n所以 在我们重写了 equals() 方法时，一定要确保 hashCode() 方法能遵循上述规则\ndemo 演示 未重写 hashCode()\nUser 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 package JAVA.hash_and_equals; import java.util.HashMap; public class TestHashEquals { public static void main(String[] args) { HashMap\u0026lt;User, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(new User(\u0026#34;AKAxedx\u0026#34;), \u0026#34;111\u0026#34;); System.out.println(hashMap.get(new User(\u0026#34;AKAxedx\u0026#34;))); } } 运行结果：null\n原因：hashMap 中的 get 方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param key the key * @return the node, or null if none */ final Node\u0026lt;K,V\u0026gt; getNode(Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n, hash; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; (hash = hash(key))]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { //这里调用了 hash 进行对比 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))// 短路掉了 equals() 方法 return e; } while ((e = e.next) != null); } } return null; } 重写 User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } @Override public int hashCode() { return name.hashCode(); } } 运行结果：111\n== 和 equals 方法的区别 == 如果比较基本数据类型，比较的是值，如果是引用类型，比较的是引用地址 equals() 使用 equals() 方法比较，具体逻辑看具体实现，比如String 类型，虽然是引用类型，但是 String 重写了 equals() 方法，比较的是字符串中各个字符是否相等 String、StringBuffer、StringBuilder的区别 String 是不可变的，如果尝试修改，会生成一个字符串对象，StringBuffer 和 StringBuilder 是可变的 StringBuffer 是线程安全的，StringBuilder 是线程不安全的，单线程环境下 StringBuilder 效率更高 泛型中 extends 和 super 的区别 \u003c? extends T\u003e 表示包括 T 在内的任何 T 的子类 \u003c? super T\u003e 表示包括 T 在内的任何 T 的父类 重载和重写的区别 重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时\n重写 发生在父子类中，方法名，参数列表必须相同，返回值返回小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 private 则不能重写该方法\nList 和 Set 的区别 List 有序，按对象进入的顺序保存对象，可重复，允许多个 Null 元素对象，可以使用 Iterator 取出所有元素，再逐一遍历，还可以使用 get 获取指定下标的元素\nSet 无序，不可重复，最多允许一个 Null 元素对象，取元素时只能使用 Iterator 接口取得所有元素，再逐一遍历\nArrayList 和 LinkedList 的区别 底层数据结构不同，ArrayList 基于数组，而LinkedList 基于链表\n由于底层数据结构不同，他们使用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加。查询、添加、删除的时间复杂度不同\n都是先了 List 接口，而 LinkedList 还而额外实现了 Deque 接口，所以 LinkedList 还能当队列来使用\nConcurrentHashMap 的扩容机制 JDK 1.7版本 ConcurrentHashMap 是基于 Segment 分段实现的 每个 Segment 相当于一个小的 HashMap 每个 Segment 内部会进行扩容，和 HashMap 扩容类似 先生成新的数组，然后转移元素到新数组中 扩容的判断也是每个 Segment 内部单独判断的，判断是否超过阈值 JDK 1.8版本 不再使用 Segment 实现 当某个线程进行 put 时，如果 ConcurrentHashMap 正在扩容，那么该线程一起进行扩容 如果某个线程 put 时，没有在进行扩容，则将 key-value 添加到 ConcurrentHashMap 中，然后判断是否超过阈值，超过进行扩容 ConcurrentHashMap 支持多线程同时扩容 扩容之前生成一个新的数组 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作 JDK1.7-JDK1.8 HashMap 发生了什么变化 JDK1.7 数组 + 链表\n头插法\nhash 算法复杂\nJDK1.8 数组 + 链表 + 红黑树\n红黑树提高插入和查询的整体效率\n尾插法\nhash 算法简化\nHashMap 的 put 方法 大致如下\n通过哈希算法与与运算计算得出数组下标 如果数组下标为空，则将 key-value 封装为 Entry (1.8 版本为 Node) 对象，并放入该位置 如果是 JDK1.7，先判断是否扩容，如果扩容，就进行扩容，不扩容就生成 Entry 对象，使用头插法插入当前位置的链表中 如果是 JDK1.8，先判断该位置上的 Node 的类型（链表、红黑树） 如果是红黑树 Node，将 key-value 封装成一个 红黑树节点并添加进树中（插入/更新） 如果是链表 Node，则将 key-value 封装为一个链表 Node 并通过尾插法插入当前链表尾部，由于尾插进行了遍历，遍历过程中进行插入或更新，如果长度大于 8，将链表转换成红黑树 插入链表或红黑树后才进行判单是否进行扩容 HashMap 的扩容机制 JDK1.7 先生成新数组 遍历老数组的每个位置上的链表的每个元素 取出每个元素的 key，并基于新的数组长度，计算出每个元素再新数组中的下标 将元素添加到新数组中去 所有元素转移完后，将新数组赋值给 HashMap 对象中的 table 属性 JDK1.8 先生成新数组 遍历老数组中的每个位置的链表或红黑树 如果是链表，则直接将链表中的每个元素重新计算下标，添加到新数组中 如果是红黑树，先遍历红黑树，计算每个元素对应的下标位置 统计每个下标位置的元素个数 如果该位置的元素超过了8，生成一个新的红黑树，并将根节点的添加到新数组的对应位置 如果没有超过8，则生成一个链表，将头节点添加到数组的对应位置 所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性 深拷贝和浅拷贝 深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用\n浅拷贝是指，只拷贝基本数据类型的值，以及实例对象的引用地址，不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的属性指向的是同一个对象 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象 CopyOnWriteArrayList 的底层原理 首先 CopyOnWriteArrayList 内部也是数组，在向 CopyOnWriteArrayList 添加元素时，会赋值一个新的数组，写操作在新数组上进行，读操作在原数组上进行 写操作加锁，防止出现并发写入丢失数据的问题 写操作结束之后会把原数组指向新数组 CopyOnWriteArrayList 允许在写操作时来读数据，提高了读的性能，适合多读少写的应用场景，但是 CopyOnWriteArrayList 比较占内存，同时可能读到的数据不是最新的，不适合实时性要求很高的场景 什么是字节码，采用字节码的好处 编译器将 Java 源文件编译成字节码文件，可以做到一次编译到处允许，win 上编译好的 class 文件，可以直接在 linux 上允许，通过这种方式做到跨平台，前提是，不同的操作系统上安装的 JDK 或 JRE 是不同的，虽然字节码通用，但把字节码解释成各个操作系统机器码是需要不同的解释器的，所以各个操作系统需要自己的 JDK 和 JRE\n采用自己尔玛的好处，一方面实现了跨平台，一方面提高了代码执行的性能，编译器在编译源代码时可以做一些编译器的优化，比如锁消除、标量替换、方法内联等\nJava 异常体系 Java 中所有异常都来自顶级父类 Throwable Throwable 下有两个子类 Exception 和 Error Error 表示非常严重的错误，比如 java.lang.StackOverFlowError 和 OOM ，通常这些错误出现时，仅靠程序自己时解决不了的，可能时虚拟机、磁盘、操作系统层面出现了问题，所有通常不建议在代码中去捕获这些 Error，因为捕获的意义不大，因为程序可能已经运行不了了 Exception 表示异常，表示程序出现 Exception 时，是可以靠自己来解决的，比如空指针，数组越界等，我们可以捕获这些异常来进行特殊处理 Exception 的子类通常可分为 RuntimeException 和非 RuntimeException 异常 RuntimeException 表示运行期异常，表示这个异常实在代码运行过程中抛出的，这些事非检查异常，程序中可以选择捕获或直接抛出，这些异常一般是由逻辑错误引起的，程序应该从逻辑角度尽可能避免，比如空指针和数组越界 非 RuntimeException 表示非运行期异常，也即是检查异常，是必须进行处理的异常，如果不处理，程序就不能检查异常通过，如 IOException，SQLException 等以及用户自定义的 Exception 异常 什么时候抛出异常，什么时候捕获异常 异常是一种提示，抛出异常相当于告诉上层方法，我抛出了一个异常，我处理不了，交给你处理。而上层方法他也需要判断能否处理这个异常\n所有在写方法时，要考虑本方法能否合理地处理该异常，处理的了捕获，处理不了抛出\nJava 中有哪些类加载器 BootstrapClassLoader：是ExtClassLoader 的父类加载器，赋值加载 %JAVA_HOME%/lib 下的 jar 包和 class 文件 ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载 %JAVA_HOME%/lib/ext 文件夹下的 jar 包和 class 类 AppClassLoader 是自定义类加载器的父类，负责加载 classpath 下的类文件 类加载器双亲委派模型 JVM 中存在三个默认的类加载器\nBootstrapClassLoader ExtClassLoader AppClassLoader JVM 在加载一个类时，会调用 AppClassLoader 的 loadClass 方法来加载这个类，不管在这个方法中，会先使用 ExtClassLoader 的 loadClass 方法来加载类，同样 ExtClassLoader 的 loaderClass 会使用 BootstrapClass 的 loaderClass 方法来加载类，如果 BootstrapClassLoader 加载到了直接成功，如果没有则 ExtClassLoader 加载，如果还没有则 AppClassLoader 加载\n所以，双亲委派指的是，JVM 在加载类时，会委派给父类加载，没加载到才自己进行加载\n一个对象加载到 JVM，再到被 GC 清除，都经历了什么过程 首先把字节码文件内容加载到方法区 根据类信息再堆区创建对象 对象首先会分配再堆区中年轻代的 Eden 区，经过一次 Minor GC 后，如果对象存活，进入 Suvivor 区，在后续的每次 Minor GC中，如果对象一直存活，就会在 Suvivor 区来回拷贝，没移动一次，年龄加1 当年龄超过15后，对象依然存活，对象进入老年代 如果经过 Full GC，被标记为垃圾对象，那么就会被 GC 线程清理掉 怎么确定一个对象到底是不是垃圾 引用计数法：这种方式时给堆内存当中每个对象记录一个引用个数，引用个数为0的就认为是垃圾，这是早期 JDK 中使用的方法，引用计数无法解决循环引用的问题 可达性算法：这种方法是再内存中，从根对象一直向下找引用，找到的对象就不是垃圾，没找的是垃圾 JVM 有哪些垃圾回收算法 标记清除算法： 标记阶段：把垃圾内存标记出来 清除阶段：直接将垃圾内存回收 赭红算法简单，但会产生大量内存碎片 复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法，复制算法将内存分为大小相等的两半，每次只是用其中一半，垃圾回收时，将当前这一块的内存活对象全部拷贝到另一半，然后这一半直接清除，这种算法没有内存碎片，但是浪费空间 标记压缩法：为了解决复制算法的缺陷，提出标记压缩法，这张算法在标记阶段和清除算法一样，标记完后，不直接清除垃圾，而是将存活对象往一端移动，然后将边界外的所有内存清除 什么是 STW Stop-The-World，实在垃圾回收算法执行过程当中，需要将 JVM 内存冻结的一种状态，在 STW 状态下，Java 所有线程都是停止执行的-GC线程除外，native 方法可以执行，但是，不能与 JVM 交互，GC 各种算法优化的重点，就是减少 STW，这也是 JVM 调优的重点\nJVM 参数有哪些 绝大数情况下，常用的有十来个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # JVM 启动参数不换行 # 设置堆内存 -Xmx4g -Xms4g # 指定 GC 算法 -XX:+UseG1GC -XX:MaxGCPauseMillis=50 # 指定 GC 并行线程数 -XX:ParallelGCThreads=4 # 打印 GC 日志 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 指定 GC 日志文件 -Xloggc:gc.log # 指定 Meta 区的最大值 -XX:MaxMetaspaceSize=2g # 设置单个线程栈的大小 -Xss1m # 指定堆内存溢出时自动进行 Dump -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ","date":"2024-08-25T05:53:40+08:00","image":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/698503_hu14773505816458707756.jpg","permalink":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/","title":"Java 基础"},{"content":"备战秋招 JAVA 基础 包含 Java SE、JUC 等 Java 语言相关的特性\n具体地址\nTomcat 包含 Tomcat 相关的面试题\n具体地址\n计网基础 具体地址\nSpring 具体地址\n","date":"2024-08-25T05:44:46+08:00","image":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B_hu13581451615509590227.PNG","permalink":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/","title":"备战秋招"},{"content":"\n","date":"2024-08-25T02:25:02+08:00","image":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/image-20240825022846591_hu11050290388165439678.png","permalink":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","title":"Spring 源码解析笔记"}]