[{"content":" Tomcat 中为什么要使用自定义类加载器 一个 Tomcat 中可以部署很多个应用，而每个应用中都存在很多类，各个应用中的类是独立的，全类名是可以相同的。一个 Tomcat 不管内部部署了多少应用，Tomcat 启动之后就是一个 Java 进程，也就是一个 JVM，所以如果 Tomcat 中只存在一个类加载器，比如默认的 AppClassLoader，那么只能加载一个同名类，这是有问题的。在 Tomcat中，会为部署的每个应用都生成一个类加载器实例，叫做 WebAppClassLoader，这样 Tomcat 中每个应用都可以使用自己的类加载器去加载自己的类，实现应用之间的类隔离，不出现冲突。另外 Tomcat 还利用自定义加载器实现了热加载的功能\n","date":"2024-08-25T18:10:13+08:00","image":"https://akaxedx.github.io/p/tomcat/saber_hu18427175924411022449.jpg","permalink":"https://akaxedx.github.io/p/tomcat/","title":"Tomcat"},{"content":" JUC Java 中创建线程的方式 继承Thread类 1 2 3 4 5 6 7 8 9 10 11 public class TestThread extends Thread{ public static void main(String[] args) { TestThread thread = new TestThread(); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 由于 Java 是单继承，直接继承 Thread 会限制继承其他类，因此多用 Runnable 接口实现多线程 Thread 也是继承了 Runnable 接口的类，本质上还是等于继承了 Runnable 接口 实现Runnable接口 1 2 3 4 5 6 7 8 9 10 11 public class TestRunnable implements Runnable{ public static void main(String[] args) { Thread thread = new Thread(new TestRunnable()); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 匿名内部类实现多线程\n1 2 3 4 5 6 7 8 9 10 11 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } }); thread.start(); } } 使用 lambda 表达式简化\n1 2 3 4 5 6 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(() -\u0026gt; System.out.println(\u0026#34;111\u0026#34;)); thread.start(); } } 实现 Callable 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestCallable implements Callable\u0026lt;String\u0026gt; { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(new TestCallable()); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); System.out.println(result); } @Override public String call(){ return \u0026#34;111\u0026#34;; } } 与 Runnable 的区别在于可以拿到线程执行的结果，这里需要与 FutureTask 结合使用 而 FutureTask 是继承的 Runnable 接口和 Future 接口的接口 线程池创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestThreadPool implements Runnable{ public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new TestThreadPool()); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 总结 以上四种方式底层均为 Runnable 接口\n不建议使用 Executors 创建线程池的原因 FixedThreadPool 当我们使用 Executors 创建 FixedThreadPool 时，对应的构造方法为\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 这里 LinkedBlockingQueue 是一个无界的阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加进队列，会有 OOM 的风险 SingleThreadExecutor 当我们使用 Executors 创建 SingleThreadExecutor 时，对应的构造方法为\n1 2 3 4 5 6 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } 也是 LinkedBlockingQueue 总结 除了 OOM 的风险外，我们使用 Executors 来创建线程池也不能自定义线程的名字，不利于排查问题，所以应该用 ThreadPoolExecutor 直接定义线程池，可以灵活控制\n线程池有哪几种状态，每种状态分别表示什么 RUNNING 表示线程池正常运行，既能接收新任务，也会正常处理队列中的任务\nSHUTDOWN 当调用线程池 shutdown() 方法时，进入 SHUTDOWN 状态，表示线程池正处于关闭状态，不会接收新任务，但会继续把队列中的任务处理完\nSTOP 当调用线程池 shutdownnow() 方法时，线程池进入 STOP 状态，表示线程池正处于停止状态，此状态 不会接收新任务，也不会处理队列中的任务，正在运行的线程也会终断\nTIDYING 线程池中没有线程运行后，线程池状态自动变为 TIDYING，并且调用 terminated()，该方法是空方法，可以自行扩展\nTERMINATED terminated() 方法执行完后，线程池状态变为 TERMINATED\nSynchronized 和 ReentrantLock Synchronized ReentrantLock Java 中的一个关键值 JDK 提供的一个类 自动加锁与释放锁 手动加锁与释放 JVM 层面的锁 API 层面的锁 非公平锁 公平锁或非公平锁 锁的是对象，锁信息保存在对象头中 int 类型的 state 标识来标识锁的状态 底层有锁升级的过程 没有锁升级的过程 ReentrantLock分为公平和非公平锁，底层是怎么实现的 首先，不管是公平锁还是非公平锁，他们的底层实现都会用 AQS 来进行排队，他们的区别在于线程在使用 lock() 方法加锁时：\n公平锁：检查 AQS 队列中是否存在线程在排队，如果有，则当前线程也进行排队 非公平锁：不检查是否排队，直接竞争锁 总结 不管是否是公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁知识体现在的线程加锁阶段，而没有体现在线程被唤醒阶段\nReentrantLock 是可重入锁，不管是否公平\nSynchronized 锁是怎么升级的 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程 ID，该线程下次如果又来获取该锁就可以直接获取到了，也就是支持锁重入 轻量级锁：有偏向锁升级，当一个线程获取到锁后，此时这把锁是偏向锁，此时又有第二个线程来竞争锁，偏向锁会升级为轻量级锁，轻量级锁通过自旋实现，不会阻塞线程 自旋次数过多仍没有获取到锁，则会升级成重量级锁，重量级锁会导致线程阻塞 自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较耗费时间，自旋锁是线程通过 CAS 获取预期的一个标记，如果没获取到则循环获取，这个过程线程一直在运行中，没有使用太多操作系统资源，比较轻量 ThreadLocal的应用场景，底层实现是什么样的 ThreadLocal 底层 ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利用该机制将数据 缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据 ThreadLocal 底层是通过 ThreadLocalMap 实现的，每个 Thread 对象中都存在一个 ThreadLocalMap，Map 的 key 为 Threadlocal 对象，Map 的 value 为需要缓存的值 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestThreadLocal { private ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public void a() { local.set(\u0026#34;111\u0026#34;); b(); } public void b() { String s = local.get(); System.out.println(s); } } 在线程池中使用 ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使用完后，应该把设置的 key，value 也就是 Entry 对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap，ThreadLocalMap 也是通过强引用指向 Entry 对象，线程不被回收，Entry 对象也就不会回收，从而出现内存泄漏。解决方法是，在使用 ThreadLocal 对象后，手动调用 ThreadLocal d remove 方法，手动清除 Entry 对象 应用场景 一个经典的场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接）\nJava 核心类库及其底层原理 JDK，JRE，JVM之间的区别 JDK JDK 是 JAVA 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常见的 Java 类库等\nJRE JRE 是 Java 运行环境，用于运行 Java 的字节码文件。JRE 中包括了 JVM 以及 JVM 工作所需的类库，普通用户只需要安装 JRE 来运行 Java 程序，而程序开发者必须安装 JDK 来编译、调试程序\nJVM JAVM 是 Java 虚拟机，是 JRE 的一部分，是整个 Java 实现跨平台最核心的部分，负责运行字节码文件\ne.g. 写 Java 代码，txt 就可以写，但是写出来的代码，想要运行，需要编译成字节码，需要编译器，JDK 中包含编译器 javac，编译折后的字节码想要运行，需要一个可执行字节码的程序，这个程序就是 JVM，专门用来执行 Java 字节码的\n开发需要 JDK\n运行编译好的 Java 字节码文件需要 JRE\nJVM 在执行 Java 字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令有可能是不一样的，导致不同操作系统的 JVM 是不一样的，所以安装 JDK 时要选择操作系统\n另外 JVM 执行的是 Java 字节码，所以只要编译后是 Java 字节码，都可以在 JVM 上运行，比如 Apache Groovy，Scala ， Kotlin 等\nhashCode() 与 equals() 之间的关系 理论 在 Java 中，每个对象都可以调用自己的 hashCode() 方法得到自己的哈希值，相当于对象的指纹信息，通常来说不会有相同的，但 Java 中做不到这样绝对，但我们仍然可以使用 hashCode 来做一些判断\n如果两个对象的 hashCode 不同，这两个对象一定同 如果两个对象的 hashCode 相同，不代表一定是同一个对象 如果两个对象相等，那么 hashCode 一定相同 在 Java 的一些集合类的实现中，在比较两个对象是否相等时，会根据上面的原则，先调用 hashCode() 方法进行比较，如果不同直接判定不同，如果相同进一步调用 equals() 方法。equals() 方法就是来最终确定两个对象是不是相等的。equals() 的实现通常会很重，逻辑较多。\n所以 在我们重写了 equals() 方法时，一定要确保 hashCode() 方法能遵循上述规则\ndemo 演示 未重写 hashCode()\nUser 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 package JAVA.hash_and_equals; import java.util.HashMap; public class TestHashEquals { public static void main(String[] args) { HashMap\u0026lt;User, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(new User(\u0026#34;AKAxedx\u0026#34;), \u0026#34;111\u0026#34;); System.out.println(hashMap.get(new User(\u0026#34;AKAxedx\u0026#34;))); } } 运行结果：null\n原因：hashMap 中的 get 方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param key the key * @return the node, or null if none */ final Node\u0026lt;K,V\u0026gt; getNode(Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n, hash; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; (hash = hash(key))]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { //这里调用了 hash 进行对比 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))// 短路掉了 equals() 方法 return e; } while ((e = e.next) != null); } } return null; } 重写 User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } @Override public int hashCode() { return name.hashCode(); } } 运行结果：111\n== 和 equals 方法的区别 == 如果比较基本数据类型，比较的是值，如果是引用类型，比较的是引用地址 equals() 使用 equals() 方法比较，具体逻辑看具体实现，比如String 类型，虽然是引用类型，但是 String 重写了 equals() 方法，比较的是字符串中各个字符是否相等 String、StringBuffer、StringBuilder的区别 String 是不可变的，如果尝试修改，会生成一个字符串对象，StringBuffrt 和 StringBuilder 是可变的 StringBuffer 是线程安全的，StringBuilder 是线程不安全的，单线程环境下 StringBuilder 效率更高 泛型中 extends 和 super 的区别 \u003c? extends T\u003e 表示包括 T 在内的任何 T 的子类 \u003c? super T\u003e 表示包括 T 在内的任何 T 的父类 重载和重写的区别 重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时\n重写 发生在父子类中，方法名，参数列表必须相同，返回值返回小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 private 则不能重写该方法\nList 和 Set 的区别 List 有序，按对象进入的顺序保存对象，可重复，允许多个 Null 元素对象，可以使用 Iterator 取出所有元素，再逐一遍历，还可以使用 get 获取指定下标的元素\nSet 无序，不可重复，最多允许一个 Null 元素对象，取元素时只能使用 Iterator 接口取得所有元素，再逐一遍历\nArrayList 和 LinkedList 的区别 底层数据结构不同，ArrayList 基于数组，而LinkedList 基于链表\n由于底层数据结构不同，他们使用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加。查询、添加、删除的时间复杂度不同\n都是先了 List 接口，而 LinkedList 还而额外实现了 Deque 接口，所以 LinkedList 还能当队列来使用\nConcurrentHashMap 的扩容机制 JDK 1.7版本 ConcurrentHashMap 是基于 Segment 分段实现的 每个 Segment 相当于一个小的 HashMap 每个 Segment 内部会进行扩容，和 HashMap 扩容类似 先生成新的数组，然后转移元素到新数组中 扩容的判断也是每个 Segment 内部单独判断的，判断是否超过阈值 JDK 1.8版本 不再使用 Segment 实现 当某个线程进行 put 时，如果 ConcurrentHashMap 正在扩容，那么该线程一起进行扩容 如果某个线程 put 时，没有在进行扩容，则将 key-value 添加到 ConcurrentHashMap 中，然后判断是否超过阈值，超过进行扩容 ConcurrentHashMap 支持多线程同时扩容 扩容之前生成一个新的数组 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作 JDK1.7-JDK1.8 HashMap 发生了什么变化 JDK1.7 数组 + 链表\n头插法\nhash 算法复杂\nJDK1.8 数组 + 链表 + 红黑树\n红黑树提高插入和查询的整体效率\n尾插法\nhash 算法简化\nHashMap 的 put 方法 大致如下\n通过哈希算法与与运算计算得出数组下标 如果数组下标为空，则将 key-value 封装为 Entry (1.8 版本为 Node) 对象，并放入该位置 如果是 JDK1.7，先判断是否扩容，如果扩容，就进行扩容，不扩容就生成 Entry 对象，使用头插法插入当前位置的链表中 如果是 JDK1.8，先判断该位置上的 Node 的类型（链表、红黑树） 如果是红黑树 Node，将 key-value 封装成一个 红黑树节点并添加进树中（插入/更新） 如果是链表 Node，则将 key-value 封装为一个链表 Node 并通过尾插法插入当前链表尾部，由于尾插进行了遍历，遍历过程中进行插入或更新，如果长度大于 8，将链表转换成红黑树 插入链表或红黑树后才进行判单是否进行扩容 HashMap 的扩容机制 JDK1.7 先生成新数组 遍历老数组的每个位置上的链表的每个元素 取出每个元素的 key，并基于新的数组长度，计算出每个元素再新数组中的下标 将元素添加到新数组中去 所有元素转移完后，将新数组赋值给 HashMap 对象中的 table 属性 JDK1.8 先生成新数组 遍历老数组中的每个位置的链表或红黑树 如果是链表，则直接将链表中的每个元素重新计算下标，添加到新数组中 如果是红黑树，先遍历红黑树，计算每个元素对应的下标位置 统计每个下标位置的元素个数 如果该位置的元素超过了8，生成一个新的红黑树，并将根节点的添加到新数组的对应位置 如果没有超过8，则生成一个链表，将头节点添加到数组的对应位置 所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性 深拷贝和浅拷贝 深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用\n浅拷贝是指，只拷贝基本数据类型的值，以及实例对象的引用地址，不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的属性指向的是同一个对象 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象 CopyOnWriteArrayList 的底层原理 // TODO\n","date":"2024-08-25T05:53:40+08:00","image":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/698503_hu14773505816458707756.jpg","permalink":"https://akaxedx.github.io/p/java-%E5%9F%BA%E7%A1%80/","title":"Java 基础"},{"content":" JAVA 基础 包含 Java SE、JUC 等 Java 语言相关的特性\n具体地址\nTomcat 包含 Tomcat 相关的面试题\n具体地址\n","date":"2024-08-25T05:44:46+08:00","image":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B_hu13581451615509590227.PNG","permalink":"https://akaxedx.github.io/p/%E5%A4%87%E6%88%98%E7%A7%8B%E6%8B%9B/","title":"备战秋招"},{"content":"\n","date":"2024-08-25T02:25:02+08:00","image":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/image-20240825022846591_hu11050290388165439678.png","permalink":"https://akaxedx.github.io/p/spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","title":"Spring 源码解析笔记"}]